<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>LLVM目标无关代码生成器（下）（译） - SimpleCoding</title><meta name=author content="lazypanda"><meta name=description content="提示 ： 本文是LLVM官方文档The LLVM Target-Independent Code Generator的译文下半部分
"><meta name=keywords content='LLVM,编译器,后端,代码生成'><meta itemprop=name content="LLVM目标无关代码生成器（下）（译）"><meta itemprop=description content="提示 ： 本文是LLVM官方文档The LLVM Target-Independent Code Generator的译文下半部分"><meta itemprop=datePublished content="2024-02-06T11:46:00+08:00"><meta itemprop=dateModified content="2025-02-18T19:15:54+08:00"><meta itemprop=wordCount content="10937"><meta itemprop=keywords content="LLVM,编译器,后端,代码生成"><meta property="og:url" content="https://simplecoding.fun/posts/2024/02/llvm-code-generator-1/"><meta property="og:site_name" content="SimpleCoding"><meta property="og:title" content="LLVM目标无关代码生成器（下）（译）"><meta property="og:description" content="提示 ： 本文是LLVM官方文档The LLVM Target-Independent Code Generator的译文下半部分"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-06T11:46:00+08:00"><meta property="article:modified_time" content="2025-02-18T19:15:54+08:00"><meta property="article:tag" content="LLVM"><meta property="article:tag" content="编译器"><meta property="article:tag" content="后端"><meta property="article:tag" content="代码生成"><meta name=twitter:card content="summary"><meta name=twitter:title content="LLVM目标无关代码生成器（下）（译）"><meta name=twitter:description content="提示 ： 本文是LLVM官方文档The LLVM Target-Independent Code Generator的译文下半部分"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://simplecoding.fun/posts/2024/02/llvm-code-generator-1/ title="LLVM目标无关代码生成器（下）（译） - SimpleCoding"><link rel=prev type=text/html href=https://simplecoding.fun/posts/2024/02/llvm-code-generator-0/ title=LLVM目标无关代码生成器（上）（译）><link rel=next type=text/html href=https://simplecoding.fun/posts/2025/02/reading-xiaogouqianqian/ title=读《小狗钱钱》><link rel=alternate type=text/markdown href=https://simplecoding.fun/posts/2024/02/llvm-code-generator-1/index.md title="LLVM目标无关代码生成器（下）（译） - SimpleCoding"><link rel=stylesheet href=/css/config.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"LLVM目标无关代码生成器（下）（译）","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/simplecoding.fun\/posts\/2024\/02\/llvm-code-generator-1\/"},"image":["https:\/\/simplecoding.fun\/images\/apple-touch-icon.png"],"genre":"posts","keywords":"LLVM, 编译器, 后端, 代码生成","wordcount":10937,"url":"https:\/\/simplecoding.fun\/posts\/2024\/02\/llvm-code-generator-1\/","datePublished":"2024-02-06T11:46:00+08:00","dateModified":"2025-02-18T19:15:54+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"lazypanda","logo":"https:\/\/simplecoding.fun\/images\/avatar.jpg"},"author":{"@type":"Person","name":"lazypanda"},"description":""}</script><script src=/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=narrow><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=SimpleCoding><span class=header-title-text>SimpleCoding</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=SimpleCoding><span class=header-title-text>SimpleCoding</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class=breadcrumb-container><ol class=breadcrumb><li class=breadcrumb-item data-separator=/><a href=/ title=SimpleCoding>主页</a></li><li class=breadcrumb-item data-separator=/><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" data-separator=/ aria-current=page>LLVM目标无关代码生成器（下）（译）</li></ol></nav><main class=fi-container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class="details related-details open"><div class="details-summary related-summary"><i class="fa-solid fa-fire fa-fade text-danger fa-fw" aria-hidden=true></i>
<span class=related-title>相关内容</span><i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class="details-content related-content"><ul class=related-list><li class=related-item><a href=/posts/2024/02/llvm-code-generator-0/ title=LLVM目标无关代码生成器（上）（译）>LLVM目标无关代码生成器（上）（译）</a></li><li class=related-item><a href=/posts/2024/02/llvm-undef-poison/ title="笔记-LLVM IR中的undef和poison">笔记-LLVM IR中的undef和poison</a></li></ul></div></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>LLVM目标无关代码生成器（下）（译）</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/wanghuibin0 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img class=avatar src=/images/avatar.jpg alt=lazypanda height=16 width=16>&nbsp;lazypanda</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E6%8A%80%E6%9C%AF/ class=post-category title="分类 - 技术"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 技术</a></span></div><div class=post-meta-line><span title="发布于 2024-02-06 11:46:00"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-02-06>2024-02-06</time></span>&nbsp;<span title="更新于 2025-02-18 19:15:54"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2025-02-18>2025-02-18</time></span>&nbsp;<span title="10937 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 11000 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 22 分钟</span>&nbsp;<span id=/posts/2024/02/llvm-code-generator-1/ class=comment-visitors data-flag-title=LLVM目标无关代码生成器（下）（译）><i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=twikoo_visitors>-</span>&nbsp;次阅读
</span>&nbsp;<span id=/posts/2024/02/llvm-code-generator-1/ class=comment-count data-flag-title=LLVM目标无关代码生成器（下）（译）>
<i class="fa-regular fa-comments fa-fw me-1" aria-hidden=true></i><span id=twikoo-comment-count>-</span>&nbsp;条评论
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#机器无关代码生成算法>机器无关代码生成算法</a><ul><li><a href=#指令选择>指令选择</a><ul><li><a href=#selectiondag简介>SelectionDAG简介</a></li><li><a href=#selectiondag指令选择过程>SelectionDAG指令选择过程</a></li><li><a href=#初始dag构建>初始DAG构建</a></li><li><a href=#selectiondag类型合法化>SelectionDAG类型合法化</a></li><li><a href=#selectiondag操作合法化>SelectionDAG操作合法化</a></li><li><a href=#selectiondag优化阶段dag合并器>SelectionDAG优化阶段：DAG合并器</a></li><li><a href=#selectiondag指令选择阶段>SelectionDAG指令选择阶段</a></li><li><a href=#selectiondag调度和指令序列化阶段>SelectionDAG调度和指令序列化阶段</a></li></ul></li><li><a href=#基于ssa的机器码优化>基于SSA的机器码优化</a></li><li><a href=#活跃区间>活跃区间</a><ul><li><a href=#活跃变量分析>活跃变量分析</a></li><li><a href=#活跃区间分析>活跃区间分析</a></li></ul></li><li><a href=#寄存器分配>寄存器分配</a><ul><li><a href=#llvm中寄存器如何表示>LLVM中寄存器如何表示</a></li><li><a href=#把虚拟寄存器映射为物理寄存器>把虚拟寄存器映射为物理寄存器</a></li><li><a href=#处理二地址指令>处理二地址指令</a></li><li><a href=#ssa销毁过程>SSA销毁过程</a></li><li><a href=#指令折叠>指令折叠</a></li><li><a href=#内置寄存器分配器>内置寄存器分配器</a></li></ul></li><li><a href=#prologepilog代码插入>Prolog/Epilog代码插入</a></li><li><a href=#compact-unwind>Compact Unwind</a></li><li><a href=#晚期机器码优化>晚期机器码优化</a></li><li><a href=#代码输出>代码输出</a><ul><li><a href=#输出函数栈大小信息>输出函数栈大小信息</a></li></ul></li><li><a href=#vliw打包器>VLIW打包器</a><ul><li><a href=#从指令映射到功能单元>从指令映射到功能单元</a></li><li><a href=#打包表如何生成和使用>打包表如何生成和使用</a></li></ul></li></ul></li><li><a href=#实现独立汇编器>实现独立汇编器</a><ul><li><a href=#指令解析>指令解析</a></li><li><a href=#指令别名处理>指令别名处理</a><ul><li><a href=#助记符别名>助记符别名</a></li><li><a href=#指令别名>指令别名</a></li></ul></li><li><a href=#指令匹配>指令匹配</a></li></ul></li></ul></nav></div></div><div class=content id=content><p><strong>提示</strong> ： <em>本文是LLVM官方文档<a href=https://llvm.org/docs/CodeGenerator.html target=_blank rel="external nofollow noopener noreferrer">The LLVM Target-Independent Code Generator</a>的译文下半部分</em></p><h2 class=heading-element id=机器无关代码生成算法><span>机器无关代码生成算法</span>
<a href=#%e6%9c%ba%e5%99%a8%e6%97%a0%e5%85%b3%e4%bb%a3%e7%a0%81%e7%94%9f%e6%88%90%e7%ae%97%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>本节描述代码生成器的各个阶段，描述它们是如何工作的，以及如此设计的背后原理。</p><h3 class=heading-element id=指令选择><span>指令选择</span>
<a href=#%e6%8c%87%e4%bb%a4%e9%80%89%e6%8b%a9 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>指令选择是将LLVM IR转换为特定机器指令的过程。学术界有多种指令选择算法，而LLVM使用了基于SelectionDAG的指令选择器。</p><p>目前，DAG指令选择器的一部分是由.td文件生成的，另一部分还是需要用C++代码实现。</p><p>GlobalISel是另一个指令选择框架，目前还是实验版本。</p><h4 class=heading-element id=selectiondag简介><span>SelectionDAG简介</span>
<a href=#selectiondag%e7%ae%80%e4%bb%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>SelectionDAG提供了一种代码表示方式，对于用自动化的指令选择比较友好。另外，对于指令调度也比较友好。而且在这种表示上还可以做一些很低级的机器无关优化。</p><p>SelectionDAG是一种有向无环图，其结点是SDNode实例。SDNode主要包含了操作码和操作数。include/llvm/ISDOpcodes.h文件中描述各种操作节点类型。</p><p>实际中大多结点只是定义一个值，但每个结点都有可能定义多个值。比如，一个div/rem操作同时定义了商和余数。很多其他情形也需要多个值。每个结点还有若干操作数，表示为指向定义这些操作数的结点的边。因为结点可能定义多个值，这些边要表示为SDValue实例，即&lt;SDNode, unsigned>序对，SDNode表示来自哪个结点，unsigned表示来自其哪个结果。SDNode产生的每个值都有关联的MVT (Machine Value Type)，表示该值的类型。</p><p>SelectionDAG包含两种类型的值：表示数据依赖的，表示控制依赖的。数据值就是整数或浮点数类型的边，控制依赖边就是MVT::Other类型的chain边。这些边为有副作用的结点(load/store/call/return)提供了顺序。根据约定，chain输入总是0号操作数，chain输出总是该操作产生的最后一个值。然而，经过指令选择，机器结点也会有在指令操作数后面的chain输入，而且后面可能跟着glue结点。</p><p>SelectionDAG指定有Entry和Root结点，Entry结点是一个标记结点，其操作数总是ISD::EntryToken。Root结点是产生最终结果的结点。</p><p>对于SelectionDAG，一个重要的概念是合法或非法。合法DAG只使用目标机支持的操作和类型。类型合法化和操作合法化负责将非法DAG转换为合法DAG。</p><h4 class=heading-element id=selectiondag指令选择过程><span>SelectionDAG指令选择过程</span>
<a href=#selectiondag%e6%8c%87%e4%bb%a4%e9%80%89%e6%8b%a9%e8%bf%87%e7%a8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>包含以下步骤：</p><ol><li>构建初始DAG：从LLVM IR到非法DAG做一个简单的转换。</li><li>优化SelectionDAG：在DAG上做一些简单优化，并识别出目标机上支持的元操作，从而使得后面的转换更简单些。</li><li>类型合法化：清除目标机器上不支持的类型。</li><li>优化SelectionDAG：消除类型合法化引入的冗余。</li><li>操作合法化：清除目标机器上不支持的操作。</li><li>优化SelectionDAG：消除操作合法化引入的冗余。</li><li>从DAG上做指令选择：将机器无关的DAG输入转换为目标机指令的DAG。</li><li>SelectionDAG调度和指令序列化：给DAG中的指令指定一个线性顺序，并输出为MachineFunction。这一步使用了传统的调度技术。</li></ol><p>上述步骤完毕后，SelectionDAG被销毁，再运行的其他的代码生成pass。</p><p>为方便查看这些步骤发生的事情，可以利用LLC工具的一些选项。</p><ul><li>-view-dag-combine1-dags 显示初构建好的DAG。</li><li>-view-legalize-dags 显示合法化前的DAG。</li><li>-view-dag-combine2-dags 显示在第二步优化前的DAG。</li><li>-view-isel-dags 显示在指令选择前的DAG。</li><li>-view-sched-dags 显示在调度前的DAG。</li><li>-view-sunit-dags 显示调度器的依赖图，该图基于最终SelectionDAG。</li><li>-filter-view-dags 可以选择要查看的基本块的名称，并配合上面几个选项一起使用。</li></ul><h4 class=heading-element id=初始dag构建><span>初始DAG构建</span>
<a href=#%e5%88%9d%e5%a7%8bdag%e6%9e%84%e5%bb%ba class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>SelectionDAGBuilder类负责从LLVM IR构建SelectionDAG，这个Pass大部分都是硬编码的（LLVM add -> SDNode add, getelementptr -> 显式的算术运算），过程中需要用到机器特定hooks来lower calls, returns, varargs等。</p><h4 class=heading-element id=selectiondag类型合法化><span>SelectionDAG类型合法化</span>
<a href=#selectiondag%e7%b1%bb%e5%9e%8b%e5%90%88%e6%b3%95%e5%8c%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>使DAG只使用目标机支持的类型。</p><p>将不支持的标量类型转化为支持的类型有两种方式：一种叫promoting，将小类型转为大类型，另一种叫expanding，将大整型分解为几个小整型。</p><p>将不支持的vector类型转换为支持的类型也有两种方式：一种是将vector分割，直到找到合法的类型，另一种是通过在末尾添加元素的方式扩展vector，叫expanding。如果一个vector一路到底分割为了单个元素，还没有找到支持的vector类型，那么这些元素就会被转化为标量，叫scalarizing。</p><p>目标机实现通过调用TargetLowering中的addRegisterClass方法来告知合法化器它支持哪些类型，对应的寄存器类是什么。</p><h4 class=heading-element id=selectiondag操作合法化><span>SelectionDAG操作合法化</span>
<a href=#selectiondag%e6%93%8d%e4%bd%9c%e5%90%88%e6%b3%95%e5%8c%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>使DAG只使用目标机支持的操作。</p><p>目标机通常有古怪的约束，比如不支持某些操作。操作合法化通过用一系列操作来模拟某个不支持的操作（expansion）,或者通过将类型提升为更大类型来支持该操作（promotion）,或者通过目标特定的hook来实现合法化（custom）。</p><p>目标机实现通过调用TargetLowering中的setOperationAction方法来告知合法化器它不支持哪些操作，还有采用以上哪种方式来处理这种情况。</p><p>如果目标机有合法的vector类型，肯定希望用这些类型为shufflevector IR指令生成高效机器码，这就需要为shufflevector定制合法化操作。需要处理的形式包括以下几种：</p><ul><li><p>vector select: 就两个输入vector中挑选元素组成新的vector，这也叫做blend或者bitwise select。</p></li><li><p>Insert subvector：vector要放入从index 0开始的一个更长的vector中。</p></li><li><p>Extract subvector: 从一个长的vector的index 0处拉出子向量。</p></li><li><p>Splat: vector的所有元素都是同样的标量元素。也叫broadcast或者duplicate。</p></li></ul><p>合法化阶段的引入提供了一种SelectionDAG的标准化形式，并且可以在这种形式上做一些通用优化。</p><h4 class=heading-element id=selectiondag优化阶段dag合并器><span>SelectionDAG优化阶段：DAG合并器</span>
<a href=#selectiondag%e4%bc%98%e5%8c%96%e9%98%b6%e6%ae%b5dag%e5%90%88%e5%b9%b6%e5%99%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>在代码生成中，SelectionDAG优化会多次运行，包括DAG刚刚构建好，以及每次合法化pass之后。该pass主要是做一些清理工作。一项重要的工作就是优化插入的符号扩展和零扩展指令。目前是使用ad-hoc技术，未来可能会转为使用更严格的技术。</p><h4 class=heading-element id=selectiondag指令选择阶段><span>SelectionDAG指令选择阶段</span>
<a href=#selectiondag%e6%8c%87%e4%bb%a4%e9%80%89%e6%8b%a9%e9%98%b6%e6%ae%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>这是指令选择过程的与机器有关的主要阶段。该阶段以合法的SelectionDAG为输入，通过模式匹配选择目标机上支持的指令，并输出新的DAG。考虑如下LLVM IR:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-llvm data-lang=llvm><span class=line><span class=cl><span class=nv>%t1</span> <span class=p>=</span> <span class=k>fadd</span> <span class=kt>float</span> <span class=nv>%W</span><span class=p>,</span> <span class=nv>%X</span>
</span></span><span class=line><span class=cl><span class=nv>%t2</span> <span class=p>=</span> <span class=k>fmul</span> <span class=kt>float</span> <span class=nv>%t1</span><span class=p>,</span> <span class=nv>%Y</span>
</span></span><span class=line><span class=cl><span class=nv>%t3</span> <span class=p>=</span> <span class=k>fadd</span> <span class=kt>float</span> <span class=nv>%t2</span><span class=p>,</span> <span class=nv>%Z</span></span></span></code></pre></td></tr></table></div></div><p>对应的SelectionDAG大致如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(fadd:f32 (fmul:f32 (fadd:f32 W, X), Y), Z)</span></span></code></pre></td></tr></table></div></div><p>如果目标机支持浮点乘累加操作，那么乘和加就可以合并。在PowerPC上，指令选择器的输出大致如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(FMADDS (FADDS W, X), Y, Z)</span></span></code></pre></td></tr></table></div></div><p>PowerPC的后端会包含以下指令定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def FMADDS : AForm_1&lt;59, 29,
</span></span><span class=line><span class=cl>                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
</span></span><span class=line><span class=cl>                    &#34;fmadds $FRT, $FRA, $FRC, $FRB&#34;,
</span></span><span class=line><span class=cl>                    [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
</span></span><span class=line><span class=cl>                                           F4RC:$FRB))]&gt;;
</span></span><span class=line><span class=cl>def FADDS : AForm_2&lt;59, 21,
</span></span><span class=line><span class=cl>                    (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRB),
</span></span><span class=line><span class=cl>                    &#34;fadds $FRT, $FRA, $FRB&#34;,
</span></span><span class=line><span class=cl>                    [(set F4RC:$FRT, (fadd F4RC:$FRA, F4RC:$FRB))]&gt;;</span></span></code></pre></td></tr></table></div></div><p>TableGen DAG指令选择器从.td文件中读取指令模式，并自动构建模式匹配代码。它具有以下优势：</p><ul><li><p>在编译器自身的编译阶段，可以分析指令模式并告诉你该模式是否有意义。</p></li><li><p>在模式匹配时处理操作数约束。比如，很方便表达"匹配一个13
bit的符号扩展立即数"。</p></li><li><p>知悉关于模式一些重要性质。比如，知悉加法符合交换律。</p></li><li><p>具有功能齐全的类型推理系统。基本上不需要显式说明模式的每个部分是什么类型的。</p></li><li><p>目标机可以定义它们自己的模式片段。模式片段就是命名并可重用的模式。</p></li><li><p>除了指令，目标机还可以利用Pat类指定可以映射到单个或多个指令模式。比如，PowerPC不具有在一条指令中奖任意整型立即数搬到寄存器的方式，那么就可以在tblgen中做如下定义：</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// Arbitrary immediate support.  Implement in terms of LIS/ORI.
</span></span><span class=line><span class=cl>def : Pat&lt;(i32 imm:$imm),
</span></span><span class=line><span class=cl>          (ORI (LIS (HI16 imm:$imm)), (LO16 imm:$imm))&gt;;</span></span></code></pre></td></tr></table></div></div><ul><li>当使用Pat类将一个模式映射为一条具有单个或多个操作数的指令时，该模式要么用ComplexPattern指定为一个整体，要么分开指定操作数的各个部分。比如，使用后者的PowerPC的后端做了如下定义：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def STWU  : DForm_1&lt;37, (outs ptr_rc:$ea_res), (ins GPRC:$rS, memri:$dst),
</span></span><span class=line><span class=cl>                &#34;stwu $rS, $dst&#34;, LdStStoreUpd, []&gt;,
</span></span><span class=line><span class=cl>                RegConstraint&lt;&#34;$dst.reg = $ea_res&#34;&gt;, NoEncode&lt;&#34;$ea_res&#34;&gt;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def : Pat&lt;(pre_store GPRC:$rS, ptr_rc:$ptrreg, iaddroff:$ptroff),
</span></span><span class=line><span class=cl>          (STWU GPRC:$rS, iaddroff:$ptroff, ptr_rc:$ptrreg)&gt;;</span></span></code></pre></td></tr></table></div></div><ul><li>即便该系统已经很自动化了，仍然需要定制一些C++代码来匹配特殊情形。</li></ul><p>尽管有很多优点，该系统目前也有一些缺陷，主要是由于还有一些未完成的工作：</p><ul><li><p>没有提供能定义多个值的SelectionDAG结点。这是仍然需要定制C++代码的主要原因。</p></li><li><p>尚未有支持复杂寻址模式的好的方式。未来将会扩展模式片段使之能够定义多个值。</p></li><li><p>无法自动推导类似isStore/isLoad的flag。</p></li><li><p>无法为合法化器自动生成所支持的寄存器和操作集合。</p></li><li><p>还没有绑定自定义合法化结点的方法。</p></li></ul><p>尽管有这些限制，指令选择器生成器对于大多数的二元操作和逻辑操作指令仍然非常有用。</p><h4 class=heading-element id=selectiondag调度和指令序列化阶段><span>SelectionDAG调度和指令序列化阶段</span>
<a href=#selectiondag%e8%b0%83%e5%ba%a6%e5%92%8c%e6%8c%87%e4%bb%a4%e5%ba%8f%e5%88%97%e5%8c%96%e9%98%b6%e6%ae%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>依据目标机器的各种约束，将机器指令的DAG指派一个顺序。顺序一旦建立，DAG就转换为MachineInstr列表，而后SelectionDAG就销毁了。</p><p>该阶段在逻辑上与指令选择是分开的，但是联系很紧密，因为该阶段的输入正是SelectionDAG。</p><h3 class=heading-element id=基于ssa的机器码优化><span>基于SSA的机器码优化</span>
<a href=#%e5%9f%ba%e4%ba%8essa%e7%9a%84%e6%9c%ba%e5%99%a8%e7%a0%81%e4%bc%98%e5%8c%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>TODO</p><h3 class=heading-element id=活跃区间><span>活跃区间</span>
<a href=#%e6%b4%bb%e8%b7%83%e5%8c%ba%e9%97%b4 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>活跃区间表示一个变量在哪个范围内是活跃的（live）。某些寄存器分配器会根据该信息确定需要相同物理寄存器的几个虚拟寄存器是否在某些程序点上同时活跃，即它们产生了冲突。如果产生了冲突，就要把某个虚拟寄存器溢出（spill）。</p><h4 class=heading-element id=活跃变量分析><span>活跃变量分析</span>
<a href=#%e6%b4%bb%e8%b7%83%e5%8f%98%e9%87%8f%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>确定变量活跃区间的第一步就是计算指令执行后立即失效的寄存器集合（即指令计算了值，但后续不再使用），和本条指令中使用但后续不再使用的寄存器集合（即被杀死）。需要对每个虚拟寄存器和可分配的物理寄存器计算活跃变量信息，由于可以使用SSA对虚拟寄存器进行稀疏生命期分析，而且只需要跟踪一个基本块内的物理寄存器，这项任务可以很高效地完成。在寄存器分配之前，LLVM假设物理寄存器只在单个基本块活跃，这就使得通过局部分析就可以解析出物理寄存器的生命期。而如果一个物理寄存器不是可分配的（比如栈指针或条件码），就不需要跟踪它。</p><p>物理寄存器可能以活跃的状态流入或流出一个函数。流入的值常常是寄存器传递的参数，流出的值常常是寄存器传递的返回值。这些值在活跃区间分析中要打上特殊的标记。</p><p>PHI结点需要特殊处理，主要是因为在计算活跃变量信息时，对CFG的DFS遍历无法保证PHI结点使用的虚拟寄存器在使用前定义。当遇到PHI结点时，只处理定义，这是因为其使用会在其他基本块中处理。</p><p>对于当前基本块的每个PHI结点，要在当前基本块末尾模拟一个赋值语句并遍历后继基本块。如果后继基本块有PHI结点，且PHI结点的操作数来自于当前基本块，那么该变量就标记为在当前基本块中以及所有的前驱基本块中都是活跃的，直到碰到定义该变量的那个基本块。</p><h4 class=heading-element id=活跃区间分析><span>活跃区间分析</span>
<a href=#%e6%b4%bb%e8%b7%83%e5%8c%ba%e9%97%b4%e5%88%86%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>现在有了足够的信息来做活跃区间分析。从给基本块和机器指令编号开始，接着处理流入的活跃值，这些值都是在物理寄存器中，所以在基本块末尾可以认为这些寄存器都死亡了。而对于虚拟寄存器，会计算出一个[i,
j)形式的活跃区间，其中i, j都是指令编号。</p><h3 class=heading-element id=寄存器分配><span>寄存器分配</span>
<a href=#%e5%af%84%e5%ad%98%e5%99%a8%e5%88%86%e9%85%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>寄存器分配问题就是将一个使用无限虚拟寄存器的程序，映射为只使用有限物理寄存器的程序。每个机器架构都有不同数量的物理寄存器，如果物理寄存器不够容纳所有的虚拟寄存器，一些虚拟寄存器就会被映射到内存，这叫spilled
virtuals。</p><h4 class=heading-element id=llvm中寄存器如何表示><span>LLVM中寄存器如何表示</span>
<a href=#llvm%e4%b8%ad%e5%af%84%e5%ad%98%e5%99%a8%e5%a6%82%e4%bd%95%e8%a1%a8%e7%a4%ba class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>LLVM中物理寄存器用1~1023范围的整数来表示，可以阅读GenRegisterNames.inc文件来查看具体某个架构是怎么编号的，比如查阅lib/Target/X86/X86GenRegisterInfo.inc就可以直到EAX寄存器编号为43，MMX寄存器MM0编号为65。</p><p>一些架构含有物理位置相同的寄存器，如X86架构的EAX, AX, AL共享了前8bit。这些物理寄存器在LLVM中标记为别名。可以查阅RegisterInfo.td文件来检查某个架构的哪些寄存器是别名。而且，MCRegAliasIterator类可以枚举出跟某一个寄存器别名的所有物理寄存器。</p><p>物理寄存器在LLVM中被分组为寄存器类。同一个寄存器类中的寄存器是功能等价的，可以互换使用。每个虚拟寄存器只能被映射到某个寄存器类中的物理寄存器。例如，X86上，一些虚拟寄存器只能分配到8bit寄存器中。寄存器类用TargetRegisterClass对象描述，要想检查一个虚拟寄存器跟物理寄存器是否兼容，可以使用以下代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>bool</span> <span class=n>RegMapping_Fer</span><span class=o>::</span><span class=n>compatible_class</span><span class=p>(</span><span class=n>MachineFunction</span> <span class=o>&amp;</span><span class=n>mf</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                      <span class=kt>unsigned</span> <span class=n>v_reg</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                      <span class=kt>unsigned</span> <span class=n>p_reg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>TargetRegisterInfo</span><span class=o>::</span><span class=n>isPhysicalRegister</span><span class=p>(</span><span class=n>p_reg</span><span class=p>)</span> <span class=o>&amp;&amp;</span>
</span></span><span class=line><span class=cl>         <span class=s>&#34;Target register must be physical&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=n>TargetRegisterClass</span> <span class=o>*</span><span class=n>trc</span> <span class=o>=</span> <span class=n>mf</span><span class=p>.</span><span class=n>getRegInfo</span><span class=p>().</span><span class=n>getRegClass</span><span class=p>(</span><span class=n>v_reg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>trc</span><span class=o>-&gt;</span><span class=n>contains</span><span class=p>(</span><span class=n>p_reg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>有时为了调试需求，需要改变目标机可用的物理寄存器数量。这项任务必须在TargetRegisterInfo.td中静态完成，RegisterClass的最后一个参数就是寄存器列表，如果需要避免使用某些寄存器，就从这里注释掉。</p><p>虚拟寄存器也是用整数表示的。与物理寄存器不同，不同的虚拟寄存器从来不会共享编号。物理寄存器是在TargetRegisterInfo.td中事先定义好的，不能由应用开发者创建，而虚拟寄存器不是这样。为了创建新的虚拟寄存器，可以使用MachineRegisterInfo::createVirtualRegister()方法，它会返回一个新的虚拟寄存器。用IndexedMap&lt;Foo, VirtReg2IndexFunctor>来容纳每个虚拟寄存器的信息。如果需要枚举所有的虚拟寄存器，就使用TargetRegisterInfo::index2VirtReg()方法来找到虚拟寄存器编号：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>e</span> <span class=o>=</span> <span class=n>MRI</span><span class=o>-&gt;</span><span class=n>getNumVirtRegs</span><span class=p>();</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>e</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>unsigned</span> <span class=n>VirtReg</span> <span class=o>=</span> <span class=n>TargetRegisterInfo</span><span class=o>::</span><span class=n>index2VirtReg</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>stuff</span><span class=p>(</span><span class=n>VirtReg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>在寄存器分配之前，虽然物理寄存器也有使用，不过指令操作数大部分都是虚拟寄存器。为了检查给定的操作数是否是寄存器，可以用MachineOperand::isRegister()方法。为了获得寄存器的整数编号，使用MachineOperand::getReg()。指令可能定义或使用寄存器。比如ADD reg:1026 := reg:1025 reg:1024使用了寄存器1024和1025，而定义了1026。给定寄存器操作数，方法MachineOperand::isUse()返回该寄存器是否被使用，而MachineOperand::isDef()返回该寄存器是否被定义。</p><p>我们将寄存器分配之前存在于LLVM IR中的物理寄存器叫做pre-colored寄存器。这类寄存器用于很多场景，比如，函数调用的参数传递，存储特殊指令的结果。有两类pre-colored寄存器：隐式定义的，显式定义的。后者就是正常的操作数，可以通过MachineInstr::getOperand(int)::getReg()来访问。而要想访问前者，就用TargetInstrInfo::get(opcode)::ImplicitDefs，其中opcode就是该指令的操作码。显式和隐式物理寄存器的重要区别就是后者是每条指令静态定义的，而前者会依赖具体被编译的程序而变化。例如，函数调用总是隐式定义或使用相同的物理寄存器集合。Pre-colored寄存器会给寄存器分配算法施加约束，寄存器分配器必须确保它们在活跃期间都不能被虚拟寄存器中的值所覆盖。</p><h4 class=heading-element id=把虚拟寄存器映射为物理寄存器><span>把虚拟寄存器映射为物理寄存器</span>
<a href=#%e6%8a%8a%e8%99%9a%e6%8b%9f%e5%af%84%e5%ad%98%e5%99%a8%e6%98%a0%e5%b0%84%e4%b8%ba%e7%89%a9%e7%90%86%e5%af%84%e5%ad%98%e5%99%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>映射有两种方式：一是直接映射，使用TargetRegisterInfo和MachineOperand类中的方法；二是间接影射，依赖VirtRegMap类来插入load/store指令。</p><p>直接映射给寄存器分配器的开发者提供了更多灵活性，但是，也更容易出错，并且需要更多的实现工作。程序员需要指明在哪里插入laod和store指令。为了将某个物理寄存器指派给某个虚拟寄存器，用MachineOperand::setReg(p_reg)，插入store指令用TargetInstrInfo::storeRegToStackSlot(&mldr;)，插入load指令用TargetInstrInfo::loadRegFromStackSlot。</p><p>间接映射使开发者免于插入load/store指令的复杂性。用VirtRegMap::assignVirt2Phys(vreg,
preg)将虚拟寄存器映射为物理寄存器，用VirtRegMap::assignVirt2StackSlot(vreg)将虚拟寄存器映射到内存，并返回映射的那个stack slot位置。如果需要将另一个虚拟寄存器映射到相同的stack
slot，要用VirtRegMap::assignVirt2StackSlot(vreg, stack_location)。需要注意的一点是，当使用间接映射时，即便虚拟寄存器映射到了内存，仍然需要将它映射到物理寄存器，在对应值store之前，或reload之后，这个物理寄存器就是保存该值的位置。</p><p>如果使用间接映射，在虚拟寄存器映射到物理寄存器或栈槽之后，还需要使用spiller对象防止load/store指令。每个被映射到栈槽的虚拟寄存器在被定义之后都需要store到栈槽中，并在使用之前load回来。spiller的实现会尝试回收利用load/store指令，从而避免冗余。</p><h4 class=heading-element id=处理二地址指令><span>处理二地址指令</span>
<a href=#%e5%a4%84%e7%90%86%e4%ba%8c%e5%9c%b0%e5%9d%80%e6%8c%87%e4%bb%a4 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>LLVM机器码指令一般都是三地址指令，也就是说，最多定义一个寄存器，使用两个寄存器。但是有些架构使用二地址指令，被定义的寄存器同时也是被使用的寄存器中的一个，例如，X86中的ADD %EAX, %EBX表示%EAX = %EAX + %EBX.。</p><p>为了生成正确代码，LLVM必须将这类指令转化为二地址指令。LLVM提供了TwoAddressInstructionPass
来处理这种情况，且需要在寄存器分配前调用。调用之后生成的代码不再是SSA形式了，比如，%a = ADD %b %c会被转化为如下代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>%a = MOVE %b
</span></span><span class=line><span class=cl>%a = ADD %a %c</span></span></code></pre></td></tr></table></div></div><p>注意，在LLVM内部，第二条指令被表示为 ADD %a[def/use] %c。</p><h4 class=heading-element id=ssa销毁过程><span>SSA销毁过程</span>
<a href=#ssa%e9%94%80%e6%af%81%e8%bf%87%e7%a8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>在寄存器分配过程中发生的一个重要转换是SSA的销毁。SSA形式简化了CFG上执行的很多分析，但是传统指令集是不实现PHI指令的，因此，为了生成可执行代码，编译器必须将PHI指令替换为等价的其他指令。</p><p>消除PHI指令有多种方式，最传统的一种就是用copy指令替换PHI，这也是LLVM采取的策略。SSA销毁算法实现在lib/CodeGen/PHIElimination.cpp中。为了调用该Pass，需要打上PHIEliminationID标识符作为标记，因为寄存器分配器需要它。</p><h4 class=heading-element id=指令折叠><span>指令折叠</span>
<a href=#%e6%8c%87%e4%bb%a4%e6%8a%98%e5%8f%a0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>指令折叠是在寄存器分配期间删除冗余copy指令的优化。比如，以下指令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>%EBX = LOAD %mem_address
</span></span><span class=line><span class=cl>%EAX = COPY %EBX</span></span></code></pre></td></tr></table></div></div><p>可以被安全替换为如下单条指令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>%EAX = LOAD %mem_address</span></span></code></pre></td></tr></table></div></div><p>通过TargetRegisterInfo::foldMemoryOperand(...)方法可以将指令折叠。不过指令折叠时需要小心，折叠后的指令可能跟原始指令有相当大的差别。</p><h4 class=heading-element id=内置寄存器分配器><span>内置寄存器分配器</span>
<a href=#%e5%86%85%e7%bd%ae%e5%af%84%e5%ad%98%e5%99%a8%e5%88%86%e9%85%8d%e5%99%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>LLVM基础设施提供了四种不同的寄存器分配器：</p><ul><li><p>Fast &mdash; 是debug构建中默认使用的分配器。在基本块级别分配寄存器，尽量将值保存在寄存器中。</p></li><li><p>Basic &mdash; 一种增量的寄存器分配方法。通过启发式算法给寄存器指派活跃范围，每次一个。由于分配期间代码可能被改写，该框架允许分配器作为扩展实现。这并不是一个生产级别的分配器，但是在修复bug时很有用，而且可以作为性能基准。</p></li><li><p>Greedy &mdash; 默认的分配器。在Basic分配器基础上做了高度调优，引入了全局活跃范围分割。该分配器致力于使溢出代码的代价最小化。</p></li><li><p>PBQP &mdash; 基于PBQP的分配器。该分配器将寄存器分配问题建模为PBQP问题，然后使用PBQP求解器解决它，再把答案映射为寄存器的指派方案。</p></li></ul><p>llc使用的寄存器分配器的类型可以在命令行用-regalloc=&mldr;选项指定：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ llc -regalloc<span class=o>=</span>linearscan file.bc -o ln.s
</span></span><span class=line><span class=cl>$ llc -regalloc<span class=o>=</span>fast file.bc -o fa.s
</span></span><span class=line><span class=cl>$ llc -regalloc<span class=o>=</span>pbqp file.bc -o pbqp.s</span></span></code></pre></td></tr></table></div></div><h3 class=heading-element id=prologepilog代码插入><span>Prolog/Epilog代码插入</span>
<a href=#prologepilog%e4%bb%a3%e7%a0%81%e6%8f%92%e5%85%a5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>TODO</p><h3 class=heading-element id=compact-unwind><span>Compact Unwind</span>
<a href=#compact-unwind class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>TODO:</p><h3 class=heading-element id=晚期机器码优化><span>晚期机器码优化</span>
<a href=#%e6%99%9a%e6%9c%9f%e6%9c%ba%e5%99%a8%e7%a0%81%e4%bc%98%e5%8c%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>TODO</p><h3 class=heading-element id=代码输出><span>代码输出</span>
<a href=#%e4%bb%a3%e7%a0%81%e8%be%93%e5%87%ba class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>代码输出负责将代码生成器中的抽象表示（MachineFunction, MachineInstr等）lower到MC层使用的抽象表示（MCInst, MCStreamer等）。几个不同类合作完成这项任务：机器无关的AsmPrinter类，机器相关的AsmPrinter的子类，以及TargetLoweringObjectFile类。</p><p>MC层属于obj文件的抽象，不再有函数、全局变量等概念。相反，它会考虑标号，directive，指令等概念。此时使用的关键类是MCStreamer，它是可以用多种方式实现（输出.s或.o）的抽象API。MCStreamer针对每个directive有一个方法，比如EmitLabel, EmitSymbolAttribute, switchSection等，这都跟汇编级的directive是对应的。</p><p>如果对为某个机器实现代码生成器感兴趣，那么徐璈实现三件事情：</p><ol><li><p>首先，需要继承AsmPrinter。该类将MachineFunction向下转换为MC标号。AsmPrinter基类提供了一系列有用的方法和例程，并允许覆盖其向下转换过程。如果想实现ELF，COFF，或者MachO格式的机器，可以复用很多已实现的代码，因为TargetLoweringObjectFile类已经实现了大部分公共逻辑。</p></li><li><p>其次，需要为你的目标机实现指令打印器。指令打印器以MCInst为输入，将其渲染成文本输出到raw_ostream。这里大部分都可以从.td文件中自动生成，但是仍然需要实现打印操作数的例程。</p></li><li><p>再次，需要实现从MachineInstr到MCInst的向下转换，常常实现在&lt;target>MCInstLower.cpp文件中。这个向下转换过程经常是目标机相关的，负责将跳转表条目、常量池索引、全局变量地址转换为MCLabels。该转换层负责将代码生成器使用的微操作扩展为对应的实际机器指令，生成的MCInsts会交给指令打印器或者编码器。</p></li></ol><p>最后，根据你的选择，你也可以为MCCodeEmitter实现一个子类，将MCInst向下转换为机器码字节和重定位。如果你想要支持.o文件输出，或者想实现一个汇编器，这一步就很重要。</p><h4 class=heading-element id=输出函数栈大小信息><span>输出函数栈大小信息</span>
<a href=#%e8%be%93%e5%87%ba%e5%87%bd%e6%95%b0%e6%a0%88%e5%a4%a7%e5%b0%8f%e4%bf%a1%e6%81%af class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>当TargetLoweringObjectFile::StackSizesSection非空，且设置了TargetOptions::EmitStackSizeSection (-stack-size-section)时，包含函数栈大小元信息的section就会输出。该section包含一个数组，其元素是函数符号值和栈大小组成的有序对。当然栈大小仅包含在函数prologue中申请的栈空间，不包括动态栈申请。</p><h3 class=heading-element id=vliw打包器><span>VLIW打包器</span>
<a href=#vliw%e6%89%93%e5%8c%85%e5%99%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>在超长指令字架构上，编译器负责将指令映射到硬件功能单元上。为此，编译器会创建叫做packets或bundles的指令组。LLVM中的VLIW打包器就是完成机器指令打包的机器无关机制。</p><h4 class=heading-element id=从指令映射到功能单元><span>从指令映射到功能单元</span>
<a href=#%e4%bb%8e%e6%8c%87%e4%bb%a4%e6%98%a0%e5%b0%84%e5%88%b0%e5%8a%9f%e8%83%bd%e5%8d%95%e5%85%83 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>典型的VLIW机器指令会映射到多个功能单元。在打包过程中，编译器必须能够推理出一条指令是否能添加到指令包中。由于编译器需要检查所有可能的映射，这个决策过程可能会很复杂。因此，为了缓解这种复杂性，VLIW打包器会解析目标机的指令类，并在编译器构建期间生成表。可以通过机器无关的API查询这些表，来决定一条指令是否要容纳进一个指令包中。</p><h4 class=heading-element id=打包表如何生成和使用><span>打包表如何生成和使用</span>
<a href=#%e6%89%93%e5%8c%85%e8%a1%a8%e5%a6%82%e4%bd%95%e7%94%9f%e6%88%90%e5%92%8c%e4%bd%bf%e7%94%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>打包器从目标机的itinerary描述中读取指令类，构建一个DFA来表示指令包的状态。一个DFA包含三个主要元素：输入、状态、转换。DFA的输入集合表示正在被添加到指令包中的指令，状态表示指令所消耗的可能的功能单元。在DFA中，从一个状态到另一个状态的转换发生在给已存在的指令包添加指令时。如果从功能单元到指令的合法映射存在，那么DFA就包含相应的转换。如果转换不存在，就意味着合法的映射不存在，指令不能添加到指令包中。</p><p>为了给VLIW机器生成表，需要在Makefile中将<em>Target</em>GenDFAPacketizer.inc添加为目标。导出的API提供了三个函数：DFAPacketizer::clearResources(), DFAPacketizer::reserveResources(MachineInstr *MI), 和 DFAPacketizer::canReserveResources(MachineInstr *MI).。这些函数允许打包器将一条指令添加到已存在的指令包中，以及检查指令是否能被添加到指令包中。</p><h2 class=heading-element id=实现独立汇编器><span>实现独立汇编器</span>
<a href=#%e5%ae%9e%e7%8e%b0%e7%8b%ac%e7%ab%8b%e6%b1%87%e7%bc%96%e5%99%a8 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>LLVM支持实现完整的独立汇编器。其大部分代码都是从td文件中生成的。</p><h3 class=heading-element id=指令解析><span>指令解析</span>
<a href=#%e6%8c%87%e4%bb%a4%e8%a7%a3%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h3 class=heading-element id=指令别名处理><span>指令别名处理</span>
<a href=#%e6%8c%87%e4%bb%a4%e5%88%ab%e5%90%8d%e5%a4%84%e7%90%86 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>指令解析一旦完成，就会进入MatchInstructionImpl函数。该函数做别名处理然后做实际的匹配。</p><p>别名处理是将相同指令的不同文本形式处理为一种标准形式。可能实现的别名有多种，下面按照它们被处理的顺序列出来了。通常情况下，你会想用第一种别名机制来满足实际需要，因为它允许更简洁的描述。</p><h4 class=heading-element id=助记符别名><span>助记符别名</span>
<a href=#%e5%8a%a9%e8%ae%b0%e7%ac%a6%e5%88%ab%e5%90%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>别名处理的第一步是简单的指令助记符重映射，它就是一种简单的从一种输入助记符到输出助记符的无条件重映射。这种别名不会去看操作数，所以这种重映射必须对给定的助记符的所有形式都适用。助记符别名的定义是很简单的，比如X86如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def : MnemonicAlias&lt;&#34;cbw&#34;,     &#34;cbtw&#34;&gt;;
</span></span><span class=line><span class=cl>def : MnemonicAlias&lt;&#34;smovq&#34;,   &#34;movsq&#34;&gt;;
</span></span><span class=line><span class=cl>def : MnemonicAlias&lt;&#34;fldcww&#34;,  &#34;fldcw&#34;&gt;;
</span></span><span class=line><span class=cl>def : MnemonicAlias&lt;&#34;fucompi&#34;, &#34;fucomip&#34;&gt;;
</span></span><span class=line><span class=cl>def : MnemonicAlias&lt;&#34;ud2a&#34;,    &#34;ud2&#34;&gt;;</span></span></code></pre></td></tr></table></div></div><p>有了这类定义，助记符就可以简单直接地重映射。虽然助记符别名不会看指令内部信息，但是它们会通过Requires子句依赖于全局模式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def : MnemonicAlias&lt;&#34;pushf&#34;, &#34;pushfq&#34;&gt;, Requires&lt;[In64BitMode]&gt;;
</span></span><span class=line><span class=cl>def : MnemonicAlias&lt;&#34;pushf&#34;, &#34;pushfl&#34;&gt;, Requires&lt;[In32BitMode]&gt;;</span></span></code></pre></td></tr></table></div></div><p>该例子中，根据当前指令集，助记符被映射到不同的指令。</p><h4 class=heading-element id=指令别名><span>指令别名</span>
<a href=#%e6%8c%87%e4%bb%a4%e5%88%ab%e5%90%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>别名处理的最一般步骤发生在匹配时：它提供了匹配器的新形式来匹配特定的指令生成。指令别名有两部分：要匹配的字符串和要生成的指令。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def : InstAlias&lt;&#34;movsx $src, $dst&#34;, (MOVSX16rr8W GR16:$dst, GR8  :$src)&gt;;
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;movsx $src, $dst&#34;, (MOVSX16rm8W GR16:$dst, i8mem:$src)&gt;;
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;movsx $src, $dst&#34;, (MOVSX32rr8  GR32:$dst, GR8  :$src)&gt;;
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;movsx $src, $dst&#34;, (MOVSX32rr16 GR32:$dst, GR16 :$src)&gt;;
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;movsx $src, $dst&#34;, (MOVSX64rr8  GR64:$dst, GR8  :$src)&gt;;
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;movsx $src, $dst&#34;, (MOVSX64rr16 GR64:$dst, GR16 :$src)&gt;;
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;movsx $src, $dst&#34;, (MOVSX64rr32 GR64:$dst, GR32 :$src)&gt;;</span></span></code></pre></td></tr></table></div></div><p>这展示了一个强大的指令别名例子，根据汇编中存在哪些操作数，以多种不同的方式匹配相同的助记符。指令别名的结果可以包含以不同于目标指令的顺序排列的操作数,并且可以多次使用同一个输入，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def : InstAlias&lt;&#34;clrb $reg&#34;, (XOR8rr  GR8 :$reg, GR8 :$reg)&gt;;
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;clrw $reg&#34;, (XOR16rr GR16:$reg, GR16:$reg)&gt;;
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;clrl $reg&#34;, (XOR32rr GR32:$reg, GR32:$reg)&gt;;
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;clrq $reg&#34;, (XOR64rr GR64:$reg, GR64:$reg)&gt;;</span></span></code></pre></td></tr></table></div></div><p>这个例子也展示了绑定的操作数只列出一次。在X86后端,XOR8rr有两个输入GR8和一个输出GR8(其中一个输入与输出绑定)。InstAliases 获取一个简化的不重复的操作数列表，指令别名的结果也可以使用立即数和固定的物理寄存器,它们在结果中会被添加为简单的立即数操作数，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// Fixed Immediate operand.
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;aad&#34;, (AAD8i8 10)&gt;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// Fixed register operand.
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;fcomi&#34;, (COM_FIr ST1)&gt;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// Simple alias.
</span></span><span class=line><span class=cl>def : InstAlias&lt;&#34;fcomi $reg&#34;, (COM_FIr RST:$reg)&gt;;</span></span></code></pre></td></tr></table></div></div><p>指令别名也可以使用Requires子句来使它们特定于具体的子目标机器。</p><p>如果后端支持，指令打印器还可以自动输出别名，而不是被别名的指令。通常这会导致代码更好更易读。如果确实需要被别名的指令，就在InstAlias定义时将0传入作为第三个参数。</p><h3 class=heading-element id=指令匹配><span>指令匹配</span>
<a href=#%e6%8c%87%e4%bb%a4%e5%8c%b9%e9%85%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>TODO</p></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/2024/02/llvm-code-generator-0/ title=LLVM目标无关代码生成器（上）（译）>LLVM目标无关代码生成器（上）（译）</a></li><li><a href=/posts/2024/02/llvm-undef-poison/ title="笔记-LLVM IR中的undef和poison">笔记-LLVM IR中的undef和poison</a></li></ul><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2025-02-18 19:15:54">更新于 2025-02-18&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/2024/02/llvm-code-generator-1/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://simplecoding.fun/posts/2024/02/llvm-code-generator-1/ data-title=LLVM目标无关代码生成器（下）（译） data-hashtags=LLVM,编译器,后端,代码生成><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://simplecoding.fun/posts/2024/02/llvm-code-generator-1/ data-hashtag=LLVM><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://simplecoding.fun/posts/2024/02/llvm-code-generator-1/ data-title=LLVM目标无关代码生成器（下）（译）><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://simplecoding.fun/posts/2024/02/llvm-code-generator-1/ data-title=LLVM目标无关代码生成器（下）（译） data-description><i class="fa-brands fa-blogger fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/llvm/ class=post-tag title="标签 - LLVM">LLVM</a><a href=/tags/%E7%BC%96%E8%AF%91%E5%99%A8/ class=post-tag title="标签 - 编译器">编译器</a><a href=/tags/%E5%90%8E%E7%AB%AF/ class=post-tag title="标签 - 后端">后端</a><a href=/tags/%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/ class=post-tag title="标签 - 代码生成">代码生成</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2024/02/llvm-code-generator-0/ class=post-nav-item rel=prev title=LLVM目标无关代码生成器（上）（译）><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>LLVM目标无关代码生成器（上）（译）</a><a href=/posts/2025/02/reading-xiaogouqianqian/ class=post-nav-item rel=next title=读《小狗钱钱》>读《小狗钱钱》<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div id=comments><div id=twikoo></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://twikoo.js.org/ rel="external nofollow noopener noreferrer">Twikoo</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.151.2"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.4.0-alpha.2-20251014082535-5c74d431"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2021 - 2025</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/wanghuibin0 target=_blank rel="external nofollow noopener noreferrer">lazypanda</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/wanghuibin0 title="Find Me on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css><script src=/lib/twikoo/twikoo.all.min.js defer></script><script src=/lib/lightgallery/lightgallery.min.js defer></script><script src=/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js defer></script><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/fuse/fuse.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=https://vercount.one/js async defer></script><script src=/posts/2024/02/llvm-code-generator-1/config/page.js defer></script><script src=/js/theme.min.js defer></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CXXK5XBPFV",{anonymize_ip:!0})</script><script src="https://www.googletagmanager.com/gtag/js?id=G-CXXK5XBPFV" async></script></body></html>