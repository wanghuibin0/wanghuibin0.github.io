<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>OCaml的PPX预处理机制解析 - SimpleCoding</title><meta name=author content="lazypanda">
<meta name=description content="一般编程语言都具备预处理机制，用于在编译前对源代码进行转换。OCaml中存在两种预处理器机制：一种基于纯文本替换，另一种则基于抽象语法树（AST）的变换，后者便是著名的PPX预处理机制，全称为Pre-Processor eXtension。本文将深入解析PPX预处理机制的原理及其应用。
"><meta name=keywords content='编译器,OCaml,编程语言'><meta itemprop=name content="OCaml的PPX预处理机制解析"><meta itemprop=description content="一般编程语言都具备预处理机制，用于在编译前对源代码进行转换。OCaml中存在两种预处理器机制：一种基于纯文本替换，另一种则基于抽象语法树（AST）的变换，后者便是著名的PPX预处理机制，全称为Pre-Processor eXtension。本文将深入解析PPX预处理机制的原理及其应用。"><meta itemprop=datePublished content="2025-02-18T00:00:00+00:00"><meta itemprop=dateModified content="2025-02-18T18:15:13+08:00"><meta itemprop=wordCount content="4625"><meta itemprop=keywords content="编译器,OCaml,编程语言"><meta property="og:url" content="https://simplecoding.fun/posts/2025/02/ocaml-ppx-preprocessor/"><meta property="og:site_name" content="SimpleCoding"><meta property="og:title" content="OCaml的PPX预处理机制解析"><meta property="og:description" content="一般编程语言都具备预处理机制，用于在编译前对源代码进行转换。OCaml中存在两种预处理器机制：一种基于纯文本替换，另一种则基于抽象语法树（AST）的变换，后者便是著名的PPX预处理机制，全称为Pre-Processor eXtension。本文将深入解析PPX预处理机制的原理及其应用。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-02-18T00:00:00+00:00"><meta property="article:modified_time" content="2025-02-18T18:15:13+08:00"><meta property="article:tag" content="编译器"><meta property="article:tag" content="OCaml"><meta property="article:tag" content="编程语言"><meta name=twitter:card content="summary"><meta name=twitter:title content="OCaml的PPX预处理机制解析"><meta name=twitter:description content="一般编程语言都具备预处理机制，用于在编译前对源代码进行转换。OCaml中存在两种预处理器机制：一种基于纯文本替换，另一种则基于抽象语法树（AST）的变换，后者便是著名的PPX预处理机制，全称为Pre-Processor eXtension。本文将深入解析PPX预处理机制的原理及其应用。"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical type=text/html href=https://simplecoding.fun/posts/2025/02/ocaml-ppx-preprocessor/ title="OCaml的PPX预处理机制解析 - SimpleCoding"><link rel=prev type=text/html href=https://simplecoding.fun/posts/2025/02/reading-xiaogouqianqian/ title=读《小狗钱钱》><link rel=alternate type=text/markdown href=https://simplecoding.fun/posts/2025/02/ocaml-ppx-preprocessor/index.md title="OCaml的PPX预处理机制解析 - SimpleCoding"><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"OCaml的PPX预处理机制解析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/simplecoding.fun\/posts\/2025\/02\/ocaml-ppx-preprocessor\/"},"image":["https:\/\/simplecoding.fun\/images\/apple-touch-icon.png"],"genre":"posts","keywords":"编译器, OCaml, 编程语言","wordcount":4625,"url":"https:\/\/simplecoding.fun\/posts\/2025\/02\/ocaml-ppx-preprocessor\/","datePublished":"2025-02-18T00:00:00+00:00","dateModified":"2025-02-18T18:15:13+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"lazypanda","logo":"https:\/\/simplecoding.fun\/images\/avatar.jpg"},"author":{"@type":"Person","name":"lazypanda"},"description":""}</script><script src=/js/head/color-scheme.min.js></script></head><body data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=narrow><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=SimpleCoding><span class=header-title-text>SimpleCoding</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=SimpleCoding><span class=header-title-text>SimpleCoding</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><a class=menu-link href=/about/><i class="fa-solid fa-user fa-fw fa-sm" aria-hidden=true></i> About</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class=breadcrumb-container><ol class=breadcrumb><li class=breadcrumb-item data-separator=/><a href=/ title=SimpleCoding>主页</a></li><li class=breadcrumb-item data-separator=/><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" data-separator=/ aria-current=page>OCaml的PPX预处理机制解析</li></ol></nav><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>OCaml的PPX预处理机制解析</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/wanghuibin0 title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=/images/avatar.jpg alt=lazypanda data-title=lazypanda width=20 height=20 class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;lazypanda</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/%E6%8A%80%E6%9C%AF/ class=post-category title="分类 - 技术"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 技术</a></span></div><div class=post-meta-line><span title="发布于 2025-02-18 00:00:00"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2025-02-18>2025-02-18</time></span>&nbsp;<span title="更新于 2025-02-18 18:15:13"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2025-02-18>2025-02-18</time></span>&nbsp;<span title="4625 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 4700 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 10 分钟</span>&nbsp;<span id=/posts/2025/02/ocaml-ppx-preprocessor/ class=comment-visitors data-flag-title=OCaml的PPX预处理机制解析><i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=twikoo_visitors>-</span>&nbsp;次阅读
</span>&nbsp;<span id=/posts/2025/02/ocaml-ppx-preprocessor/ class=comment-count data-flag-title=OCaml的PPX预处理机制解析>
<i class="fa-regular fa-comments fa-fw me-1" aria-hidden=true></i><span id=twikoo-comment-count>-</span>&nbsp;条评论
</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#什么是ppx>什么是PPX</a></li><li><a href=#为什么使用ppx>为什么使用PPX</a></li><li><a href=#ppx原理解析>PPX原理解析</a><ul><li><a href=#attributes和derivers>Attributes和Derivers</a></li><li><a href=#extension-nodes和extenders>Extension nodes和extenders</a></li></ul></li><li><a href=#ppx的使用示例>PPX的使用示例</a></li><li><a href=#编写自定义ppx扩展>编写自定义PPX扩展</a><ul><li><a href=#ppxlib>ppxlib</a></li><li><a href=#用ppxlib编写ppx扩展>用ppxlib编写PPX扩展</a><ul><li><a href=#示例1>示例1</a></li><li><a href=#示例2>示例2</a></li></ul></li></ul></li><li><a href=#ppx的缺点>PPX的缺点</a></li><li><a href=#总结>总结</a></li></ul></nav></div></div><div class=content id=content><p>一般编程语言都具备预处理机制，用于在编译前对源代码进行转换。OCaml中存在两种预处理器机制：一种基于纯文本替换，另一种则基于抽象语法树（AST）的变换，后者便是著名的PPX预处理机制，全称为Pre-Processor eXtension。本文将深入解析PPX预处理机制的原理及其应用。</p><h2 id=什么是ppx class=heading-element><span>什么是PPX</span>
<a href=#%e4%bb%80%e4%b9%88%e6%98%afppx class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>PPX是一种OCaml的预处理机制，允许开发者在编译前对源代码进行转换。它通过定义转换器（称为“扩展”）来处理特定的语法或代码模式，从而生成新的代码。一般的传统预处理器，比如C语言预处理器cpp，直接在源码层面进行文本替换，而PPX与之最大的不同在于，PPX直接操作OCaml的抽象语法树（AST），使得代码转换更加精确和安全。</p><h2 id=为什么使用ppx class=heading-element><span>为什么使用PPX</span>
<a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8ppx class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>PPX具有以下显著优势：</p><ul><li><strong>增强语言功能</strong>：通过PPX，开发者可以引入新的语法和功能，例如自定义的控制结构或领域特定语言（DSL），从而扩展OCaml的表达能力。</li><li><strong>方便获取类型信息</strong>：PPX处理阶段位于编译前期，能够方便地获取类型信息，有效弥补了OCaml程序在运行时类型信息被擦除的不足。</li><li><strong>类型安全</strong>：由于PPX操作的是OCaml的AST，转换过程是类型安全的，避免了传统预处理器可能引入的类型错误。</li></ul><h2 id=ppx原理解析 class=heading-element><span>PPX原理解析</span>
<a href=#ppx%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>在OCaml编译器将源代码编译为字节码或机器码的过程中，源代码首先被转换为一种称为抽象语法树（AST）的数据结构，OCaml实现中称之为Parsetree。PPX转换器本质上是对Parsetree进行变换，它以一个Parsetree作为输入，返回一个变换后的Parsetree，再交给编译器的后续步骤继续处理。具体而言，开发者可以在源代码中加入特定的注释或语法，PPX转换器会识别这些标记并应用相应的转换规则，将代码转换为标准的OCaml代码。这种转换是在编译前静态完成的，因此不会对编译后的性能产生影响。</p><h3 id=attributes和derivers class=heading-element><span>Attributes和Derivers</span>
<a href=#attributes%e5%92%8cderivers class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>Attributes是附加在AST节点上的附加信息，其语法形式为<code>[@attribute_name payload]</code>，其中<code>attribute_name</code>是该attribute的名字，<code>payload</code>是合法的OCaml源码。<code>@</code>的数量决定了该attribute具体附加到哪一个AST节点：<code>@</code>表示最近的节点，<code>@@</code>表示最近的block，<code>@@@</code>表示它是一个独立的浮动attribute，不附加到任何AST节点。例如，<code>[@@deriving yojson]</code>是一个附加在type定义上的attribute：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>int_pair</span> <span class=o>=</span> <span class=o>(</span><span class=kt>int</span> <span class=o>*</span> <span class=kt>int</span><span class=o>)</span> <span class=o>[@@</span><span class=n>deriving</span> <span class=n>yojson</span><span class=o>]</span></span></span></code></pre></td></tr></table></div></div><p>与attributes紧密相连的一个常见概念是derivers，它本质上是一种特殊的PPX。对于这种PPX，我们可以用attribute语法将其添加到程序中，附加到某个代码块上。在编译程序时，该PPX会处理这个代码块，并将处理后生成的代码添加到该代码块的后面。常见的derivers包括：</p><ul><li><code>ppx_show</code>：可以为某种type生成pretty printer。</li><li><code>ppx_yojson_conv</code>：可以自动生成将某种type转换为json格式的转换函数。</li></ul><h3 id=extension-nodes和extenders class=heading-element><span>Extension nodes和extenders</span>
<a href=#extension-nodes%e5%92%8cextenders class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>Extension nodes相当于Parsetree中的“空洞”，其语法形式为<code>[%extension_name payload]</code>，其中<code>%</code>的数量决定了extension node的类型：<code>%</code>表示内部节点，例如表达式或模式；<code>%%</code>表示顶层节点，例如structure中的条目。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=n>v</span> <span class=o>=</span> <span class=o>[%</span><span class=n>html</span> <span class=s2>&#34;&lt;a href=&#39;ocaml.org&#39;&gt;OCaml!&lt;/a&gt;&#34;</span><span class=o>]</span></span></span></code></pre></td></tr></table></div></div><p>一个extension node相当于一个空位，它会被一种特殊的PPX填充，而这种PPX就叫extender。具体而言，extenders会匹配extension node的名字，匹配到之后就会根据它的<code>payload</code>来生成代码，并将生成的代码替换到extension node本来的位置。需要注意的是，这个生成代码的过程只依赖于<code>payload</code>，而不会考虑该node的上下文信息。常见的extenders例子包括：<code>ppx_expect</code>可以从<code>payload</code>直接生成CRAM tests。</p><h2 id=ppx的使用示例 class=heading-element><span>PPX的使用示例</span>
<a href=#ppx%e7%9a%84%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>假设我们希望在OCaml中实现为任意类型自动生成打印函数。我们可以使用<code>ppx_deriving</code>扩展来实现这一目标。</p><ol><li>安装<code>ppx_deriving</code>：</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>opam install ppx_deriving</span></span></code></pre></td></tr></table></div></div><ol start=2><li>定义type，并加上<code>[@@deriving show]</code></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>person</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>  <span class=n>name</span> <span class=o>:</span> <span class=kt>string</span><span class=o>;</span>
</span></span><span class=line><span class=cl>  <span class=n>age</span> <span class=o>:</span> <span class=kt>int</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>[@@</span><span class=n>deriving</span> <span class=n>show</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=n>shape</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Circle</span> <span class=k>of</span> <span class=kt>float</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Rectangle</span> <span class=k>of</span> <span class=kt>float</span> <span class=o>*</span> <span class=kt>float</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=nc>Person</span> <span class=k>of</span> <span class=n>person</span>
</span></span><span class=line><span class=cl><span class=o>[@@</span><span class=n>deriving</span> <span class=n>show</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>p</span> <span class=o>=</span> <span class=o>{</span> <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;Alice&#34;</span><span class=o>;</span> <span class=n>age</span> <span class=o>=</span> <span class=n>30</span> <span class=o>}</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>s</span> <span class=o>=</span> <span class=nc>Circle</span> <span class=n>3</span><span class=o>.</span><span class=n>0</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>s2</span> <span class=o>=</span> <span class=nc>Person</span> <span class=n>p</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=c>(* Printf.printf &#34;%s\n&#34; (show_person p); *)</span>
</span></span><span class=line><span class=cl>  <span class=nn>Printf</span><span class=p>.</span><span class=n>printf</span> <span class=s2>&#34;%s</span><span class=se>\n</span><span class=s2>&#34;</span> <span class=o>(</span><span class=n>show_shape</span> <span class=n>s</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=nn>Printf</span><span class=p>.</span><span class=n>printf</span> <span class=s2>&#34;%s</span><span class=se>\n</span><span class=s2>&#34;</span> <span class=o>(</span><span class=n>show_shape</span> <span class=n>s2</span><span class=o>)</span></span></span></code></pre></td></tr></table></div></div><p>这将自动为<code>person</code>类型和shape类型生成<code>show</code>函数，用于将其转换为字符串表示。这种自动化的代码生成大大提高了开发效率。
3. 编写代码调用show</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>p</span> <span class=o>=</span> <span class=o>{</span> <span class=n>name</span> <span class=o>=</span> <span class=s2>&#34;Alice&#34;</span><span class=o>;</span> <span class=n>age</span> <span class=o>=</span> <span class=n>30</span> <span class=o>}</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>s</span> <span class=o>=</span> <span class=nc>Circle</span> <span class=n>3</span><span class=o>.</span><span class=n>0</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>s2</span> <span class=o>=</span> <span class=nc>Person</span> <span class=n>p</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=c>(* Printf.printf &#34;%s\n&#34; (show_person p); *)</span>
</span></span><span class=line><span class=cl>  <span class=nn>Printf</span><span class=p>.</span><span class=n>printf</span> <span class=s2>&#34;%s</span><span class=se>\n</span><span class=s2>&#34;</span> <span class=o>(</span><span class=n>show_shape</span> <span class=n>s</span><span class=o>);</span>
</span></span><span class=line><span class=cl>  <span class=nn>Printf</span><span class=p>.</span><span class=n>printf</span> <span class=s2>&#34;%s</span><span class=se>\n</span><span class=s2>&#34;</span> <span class=o>(</span><span class=n>show_shape</span> <span class=n>s2</span><span class=o>)</span></span></span></code></pre></td></tr></table></div></div><ol start=4><li>调用ocamlopt编译</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ ocamlfind ocamlopt -o main -package ppx_deriving.show -linkpkg main.ml</span></span></code></pre></td></tr></table></div></div><ol start=5><li>运行输出</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ ./main
</span></span><span class=line><span class=cl>(Circle 3.)
</span></span><span class=line><span class=cl>(Person { name = &#34;Alice&#34;; age = 30 })</span></span></code></pre></td></tr></table></div></div><h2 id=编写自定义ppx扩展 class=heading-element><span>编写自定义PPX扩展</span>
<a href=#%e7%bc%96%e5%86%99%e8%87%aa%e5%ae%9a%e4%b9%89ppx%e6%89%a9%e5%b1%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>编写自定义PPX扩展需要深入了解OCaml的抽象语法树（AST）和编译器的工作原理。通常，开发者需要定义一个转换器，该转换器接受一个AST并返回一个新的AST。</p><h3 id=ppxlib class=heading-element><span>ppxlib</span>
<a href=#ppxlib class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>历史上曾出现过一些用于帮助编写PPX扩展的库，如<code>ppx_tools</code>和<code>ppx_deriving</code>。然而，随着OCaml生态系统的发展，<code>ppxlib</code>逐渐成为主流。<code>ppxlib</code>是一个现代化的OCaml库，旨在简化和增强OCaml编译器扩展，尤其是PPX重写器的开发。它通过提供更高层次的抽象，使得编写和管理PPX重写器变得更加简洁和高效。<code>ppxlib</code>主要由Jane Street开发，综合了多个旧有PPX项目的能力，致力于提高PPX重写器的性能、可维护性和互操作性。</p><p>从工作原理上看，<code>ppxlib</code>对PPX重写器的核心概念进行了显著改进。传统的PPX重写器往往将整个AST视为一个黑盒子进行处理，而<code>ppxlib</code>则将扩展点视为可在编译时求值的函数，采用自上而下的求值方式。这样，重写过程被拆分为多个小函数，这些函数按照指定的顺序在编译时执行，从而提供了更高效、更灵活的处理能力。</p><h3 id=用ppxlib编写ppx扩展 class=heading-element><span>用ppxlib编写PPX扩展</span>
<a href=#%e7%94%a8ppxlib%e7%bc%96%e5%86%99ppx%e6%89%a9%e5%b1%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>本节通过两个示例来直观展示PPX扩展的编写方法。示例1针对extension nodes，示例2针对attributes。</p><h4 id=示例1 class=heading-element><span>示例1</span>
<a href=#%e7%a4%ba%e4%be%8b1 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>假设我们要通过PPX机制，将源码中的<code>[%get_env "SOME_ENV_VAR"]</code>在编译期替换成环境变量<code>SOME_ENV_VAR</code>的值，我们可以这样做：</p><ol><li>安装ppxlib</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>opam install ppxlib</span></span></code></pre></td></tr></table></div></div><ol start=2><li>用OCaml编写扩展文件ppx_get_env.ml</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>open</span> <span class=nc>Ppxlib</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>expand</span> <span class=o>~</span><span class=n>ctxt</span> <span class=n>env_var</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>loc</span> <span class=o>=</span> <span class=nn>Expansion_context</span><span class=p>.</span><span class=nn>Extension</span><span class=p>.</span><span class=n>extension_point_loc</span> <span class=n>ctxt</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=k>match</span> <span class=nn>Sys</span><span class=p>.</span><span class=n>getenv</span> <span class=n>env_var</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=k>value</span> <span class=o>-&gt;</span> <span class=nn>Ast_builder</span><span class=p>.</span><span class=nn>Default</span><span class=p>.</span><span class=n>estring</span> <span class=o>~</span><span class=n>loc</span> <span class=k>value</span>
</span></span><span class=line><span class=cl>  <span class=o>|</span> <span class=k>exception</span> <span class=nc>Not_found</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>      <span class=k>let</span> <span class=n>ext</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=nn>Location</span><span class=p>.</span><span class=n>error_extensionf</span> <span class=o>~</span><span class=n>loc</span> <span class=s2>&#34;The environement variable %s is unbound&#34;</span>
</span></span><span class=line><span class=cl>          <span class=n>env_var</span>
</span></span><span class=line><span class=cl>      <span class=k>in</span>
</span></span><span class=line><span class=cl>      <span class=nn>Ast_builder</span><span class=p>.</span><span class=nn>Default</span><span class=p>.</span><span class=n>pexp_extension</span> <span class=o>~</span><span class=n>loc</span> <span class=n>ext</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>my_extension</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=nn>Extension</span><span class=p>.</span><span class=nn>V3</span><span class=p>.</span><span class=n>declare</span> <span class=s2>&#34;get_env&#34;</span> <span class=nn>Extension</span><span class=p>.</span><span class=nn>Context</span><span class=p>.</span><span class=n>expression</span>
</span></span><span class=line><span class=cl>    <span class=nn>Ast_pattern</span><span class=p>.</span><span class=o>(</span><span class=n>single_expr_payload</span> <span class=o>(</span><span class=n>estring</span> <span class=o>__))</span>
</span></span><span class=line><span class=cl>    <span class=n>expand</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>rule</span> <span class=o>=</span> <span class=nn>Ppxlib</span><span class=p>.</span><span class=nn>Context_free</span><span class=p>.</span><span class=nn>Rule</span><span class=p>.</span><span class=n>extension</span> <span class=n>my_extension</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=bp>()</span> <span class=o>=</span> <span class=nn>Driver</span><span class=p>.</span><span class=n>register_transformation</span> <span class=o>~</span><span class=n>rules</span><span class=o>:[</span> <span class=n>rule</span> <span class=o>]</span> <span class=s2>&#34;get_env&#34;</span></span></span></code></pre></td></tr></table></div></div><p>解释一下，最后一行<code>Driver.register_transformation</code>将自定义的转换规则注册到ppxlib中。此外，通过<code>Extension.V3.declare</code>来声明一个PPX extension，其第一个参数就是extension名，最后一个参数是一个函数expand，它实现真正的转换逻辑。
3. 编写main.ml</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>let</span> <span class=bp>()</span> <span class=o>=</span> <span class=n>print_string</span> <span class=o>[%</span><span class=n>get_env</span> <span class=s2>&#34;MY_VAR&#34;</span><span class=o>]</span></span></span></code></pre></td></tr></table></div></div><ol start=4><li>编写构建脚本dune文件</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(library
</span></span><span class=line><span class=cl> (name ppx_get_env)
</span></span><span class=line><span class=cl> (kind ppx_rewriter)
</span></span><span class=line><span class=cl> (libraries ppxlib))
</span></span><span class=line><span class=cl>(executable
</span></span><span class=line><span class=cl> (public_name dppx)
</span></span><span class=line><span class=cl> (name main)
</span></span><span class=line><span class=cl> (preprocess (pps ppx_get_env)))</span></span></code></pre></td></tr></table></div></div><ol start=5><li>构建，执行</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>dune build
</span></span><span class=line><span class=cl>dune <span class=nb>exec</span> bin/main.exe</span></span></code></pre></td></tr></table></div></div><h4 id=示例2 class=heading-element><span>示例2</span>
<a href=#%e7%a4%ba%e4%be%8b2 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>假设我们要通过PPX机制，为record类型定义自动生成每个field的访问函数，我们可以这样做：</p><ol><li>编写ppx_deriving_accessors.ml</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>open</span> <span class=nc>Ppxlib</span>
</span></span><span class=line><span class=cl><span class=k>module</span> <span class=nc>List</span> <span class=o>=</span> <span class=nc>ListLabels</span>
</span></span><span class=line><span class=cl><span class=k>open</span> <span class=nn>Ast_builder</span><span class=p>.</span><span class=nc>Default</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>accessor_impl</span> <span class=o>(</span><span class=n>ld</span> <span class=o>:</span> <span class=n>label_declaration</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>loc</span> <span class=o>=</span> <span class=n>ld</span><span class=o>.</span><span class=n>pld_loc</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>pstr_value</span> <span class=o>~</span><span class=n>loc</span> <span class=nc>Nonrecursive</span>
</span></span><span class=line><span class=cl>    <span class=o>[</span>
</span></span><span class=line><span class=cl>      <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pvb_pat</span> <span class=o>=</span> <span class=n>ppat_var</span> <span class=o>~</span><span class=n>loc</span> <span class=n>ld</span><span class=o>.</span><span class=n>pld_name</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pvb_expr</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>          <span class=n>pexp_fun</span> <span class=o>~</span><span class=n>loc</span> <span class=nc>Nolabel</span> <span class=nc>None</span>
</span></span><span class=line><span class=cl>            <span class=o>(</span><span class=n>ppat_var</span> <span class=o>~</span><span class=n>loc</span> <span class=o>{</span> <span class=n>loc</span><span class=o>;</span> <span class=n>txt</span> <span class=o>=</span> <span class=s2>&#34;x&#34;</span> <span class=o>})</span>
</span></span><span class=line><span class=cl>            <span class=o>(</span><span class=n>pexp_field</span> <span class=o>~</span><span class=n>loc</span>
</span></span><span class=line><span class=cl>               <span class=o>(</span><span class=n>pexp_ident</span> <span class=o>~</span><span class=n>loc</span> <span class=o>{</span> <span class=n>loc</span><span class=o>;</span> <span class=n>txt</span> <span class=o>=</span> <span class=n>lident</span> <span class=s2>&#34;x&#34;</span> <span class=o>})</span>
</span></span><span class=line><span class=cl>               <span class=o>{</span> <span class=n>loc</span><span class=o>;</span> <span class=n>txt</span> <span class=o>=</span> <span class=n>lident</span> <span class=n>ld</span><span class=o>.</span><span class=n>pld_name</span><span class=o>.</span><span class=n>txt</span> <span class=o>});</span>
</span></span><span class=line><span class=cl>        <span class=n>pvb_attributes</span> <span class=o>=</span> <span class=bp>[]</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pvb_loc</span> <span class=o>=</span> <span class=n>loc</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=o>};</span>
</span></span><span class=line><span class=cl>    <span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>accessor_intf</span> <span class=o>~</span><span class=n>ptype_name</span> <span class=o>(</span><span class=n>ld</span> <span class=o>:</span> <span class=n>label_declaration</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>loc</span> <span class=o>=</span> <span class=n>ld</span><span class=o>.</span><span class=n>pld_loc</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=n>psig_value</span> <span class=o>~</span><span class=n>loc</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>      <span class=n>pval_name</span> <span class=o>=</span> <span class=n>ld</span><span class=o>.</span><span class=n>pld_name</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=n>pval_type</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>ptyp_arrow</span> <span class=o>~</span><span class=n>loc</span> <span class=nc>Nolabel</span>
</span></span><span class=line><span class=cl>          <span class=o>(</span><span class=n>ptyp_constr</span> <span class=o>~</span><span class=n>loc</span> <span class=o>{</span> <span class=n>loc</span><span class=o>;</span> <span class=n>txt</span> <span class=o>=</span> <span class=n>lident</span> <span class=n>ptype_name</span><span class=o>.</span><span class=n>txt</span> <span class=o>}</span> <span class=bp>[]</span><span class=o>)</span>
</span></span><span class=line><span class=cl>          <span class=n>ld</span><span class=o>.</span><span class=n>pld_type</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=n>pval_attributes</span> <span class=o>=</span> <span class=bp>[]</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=n>pval_loc</span> <span class=o>=</span> <span class=n>loc</span><span class=o>;</span>
</span></span><span class=line><span class=cl>      <span class=n>pval_prim</span> <span class=o>=</span> <span class=bp>[]</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>generate_impl</span> <span class=o>~</span><span class=n>ctxt</span> <span class=o>(_</span><span class=n>rec_flag</span><span class=o>,</span> <span class=n>type_declarations</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>loc</span> <span class=o>=</span> <span class=nn>Expansion_context</span><span class=p>.</span><span class=nn>Deriver</span><span class=p>.</span><span class=n>derived_item_loc</span> <span class=n>ctxt</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=nn>List</span><span class=p>.</span><span class=n>map</span> <span class=n>type_declarations</span> <span class=o>~</span><span class=n>f</span><span class=o>:(</span><span class=k>fun</span> <span class=o>(</span><span class=n>td</span> <span class=o>:</span> <span class=n>type_declaration</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>      <span class=k>match</span> <span class=n>td</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>       <span class=n>ptype_kind</span> <span class=o>=</span> <span class=nc>Ptype_abstract</span> <span class=o>|</span> <span class=nc>Ptype_variant</span> <span class=o>_</span> <span class=o>|</span> <span class=nc>Ptype_open</span><span class=o>;</span>
</span></span><span class=line><span class=cl>       <span class=n>ptype_loc</span><span class=o>;</span>
</span></span><span class=line><span class=cl>       <span class=o>_;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=k>let</span> <span class=n>ext</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=nn>Location</span><span class=p>.</span><span class=n>error_extensionf</span> <span class=o>~</span><span class=n>loc</span><span class=o>:</span><span class=n>ptype_loc</span>
</span></span><span class=line><span class=cl>              <span class=s2>&#34;Cannot derive accessors for non record types&#34;</span>
</span></span><span class=line><span class=cl>          <span class=k>in</span>
</span></span><span class=line><span class=cl>          <span class=o>[</span> <span class=nn>Ast_builder</span><span class=p>.</span><span class=nn>Default</span><span class=p>.</span><span class=n>pstr_extension</span> <span class=o>~</span><span class=n>loc</span> <span class=n>ext</span> <span class=bp>[]</span> <span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=o>{</span> <span class=n>ptype_kind</span> <span class=o>=</span> <span class=nc>Ptype_record</span> <span class=n>fields</span><span class=o>;</span> <span class=o>_</span> <span class=o>}</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=nn>List</span><span class=p>.</span><span class=n>map</span> <span class=n>fields</span> <span class=o>~</span><span class=n>f</span><span class=o>:</span><span class=n>accessor_impl</span><span class=o>)</span>
</span></span><span class=line><span class=cl>  <span class=o>|&gt;</span> <span class=nn>List</span><span class=p>.</span><span class=n>concat</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>generate_intf</span> <span class=o>~</span><span class=n>ctxt</span> <span class=o>(_</span><span class=n>rec_flag</span><span class=o>,</span> <span class=n>type_declarations</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=k>let</span> <span class=n>loc</span> <span class=o>=</span> <span class=nn>Expansion_context</span><span class=p>.</span><span class=nn>Deriver</span><span class=p>.</span><span class=n>derived_item_loc</span> <span class=n>ctxt</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>  <span class=nn>List</span><span class=p>.</span><span class=n>map</span> <span class=n>type_declarations</span> <span class=o>~</span><span class=n>f</span><span class=o>:(</span><span class=k>fun</span> <span class=o>(</span><span class=n>td</span> <span class=o>:</span> <span class=n>type_declaration</span><span class=o>)</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>      <span class=k>match</span> <span class=n>td</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>       <span class=n>ptype_kind</span> <span class=o>=</span> <span class=nc>Ptype_abstract</span> <span class=o>|</span> <span class=nc>Ptype_variant</span> <span class=o>_</span> <span class=o>|</span> <span class=nc>Ptype_open</span><span class=o>;</span>
</span></span><span class=line><span class=cl>       <span class=n>ptype_loc</span><span class=o>;</span>
</span></span><span class=line><span class=cl>       <span class=o>_;</span>
</span></span><span class=line><span class=cl>      <span class=o>}</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=k>let</span> <span class=n>ext</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=nn>Location</span><span class=p>.</span><span class=n>error_extensionf</span> <span class=o>~</span><span class=n>loc</span><span class=o>:</span><span class=n>ptype_loc</span>
</span></span><span class=line><span class=cl>              <span class=s2>&#34;Cannot derive accessors for non record types&#34;</span>
</span></span><span class=line><span class=cl>          <span class=k>in</span>
</span></span><span class=line><span class=cl>          <span class=o>[</span> <span class=nn>Ast_builder</span><span class=p>.</span><span class=nn>Default</span><span class=p>.</span><span class=n>psig_extension</span> <span class=o>~</span><span class=n>loc</span> <span class=n>ext</span> <span class=bp>[]</span> <span class=o>]</span>
</span></span><span class=line><span class=cl>      <span class=o>|</span> <span class=o>{</span> <span class=n>ptype_kind</span> <span class=o>=</span> <span class=nc>Ptype_record</span> <span class=n>fields</span><span class=o>;</span> <span class=n>ptype_name</span><span class=o>;</span> <span class=o>_</span> <span class=o>}</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>          <span class=nn>List</span><span class=p>.</span><span class=n>map</span> <span class=n>fields</span> <span class=o>~</span><span class=n>f</span><span class=o>:(</span><span class=n>accessor_intf</span> <span class=o>~</span><span class=n>ptype_name</span><span class=o>))</span>
</span></span><span class=line><span class=cl>  <span class=o>|&gt;</span> <span class=nn>List</span><span class=p>.</span><span class=n>concat</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>impl_generator</span> <span class=o>=</span> <span class=nn>Deriving</span><span class=p>.</span><span class=nn>Generator</span><span class=p>.</span><span class=nn>V2</span><span class=p>.</span><span class=n>make_noarg</span> <span class=n>generate_impl</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>intf_generator</span> <span class=o>=</span> <span class=nn>Deriving</span><span class=p>.</span><span class=nn>Generator</span><span class=p>.</span><span class=nn>V2</span><span class=p>.</span><span class=n>make_noarg</span> <span class=n>generate_intf</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>my_deriver</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=nn>Deriving</span><span class=p>.</span><span class=n>add</span> <span class=s2>&#34;accessors&#34;</span> <span class=o>~</span><span class=n>str_type_decl</span><span class=o>:</span><span class=n>impl_generator</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>sig_type_decl</span><span class=o>:</span><span class=n>intf_generator</span></span></span></code></pre></td></tr></table></div></div><p>最后一句通过<code>Deriving.add</code>将自定义的生成器告知ppxlib。代码中我们通过Deriving.Generator.V2.make_noarg定义了两个生成器，其中generate_impl为record定义生成访问fields的函数体，generate_intf为之生成访问fields函数的类型签名。
2. 编写main.ml</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ocaml data-lang=ocaml><span class=line><span class=cl><span class=k>type</span> <span class=n>t</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>  <span class=o>{</span> <span class=n>a</span> <span class=o>:</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>  <span class=o>;</span> <span class=n>b</span> <span class=o>:</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>  <span class=o>}</span>
</span></span><span class=line><span class=cl>  <span class=o>[@@</span><span class=n>deriving</span> <span class=n>accessors</span><span class=o>]</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=n>x</span> <span class=o>=</span> <span class=o>{</span> <span class=n>a</span> <span class=o>=</span> <span class=s2>&#34;ssss&#34;</span><span class=o>;</span> <span class=n>b</span> <span class=o>=</span> <span class=n>1</span> <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=bp>()</span> <span class=o>=</span> <span class=n>a</span> <span class=n>x</span> <span class=o>|&gt;</span> <span class=n>print_endline</span><span class=o>;</span> <span class=n>b</span> <span class=n>x</span> <span class=o>|&gt;</span> <span class=n>string_of_int</span> <span class=o>|&gt;</span> <span class=n>print_endline</span><span class=o>;</span></span></span></code></pre></td></tr></table></div></div><ol start=3><li>编写构建脚本dune</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>(library
</span></span><span class=line><span class=cl> (name ppx_deriving_accessors)
</span></span><span class=line><span class=cl> (kind ppx_deriver)
</span></span><span class=line><span class=cl> (libraries ppxlib))
</span></span><span class=line><span class=cl>(executable
</span></span><span class=line><span class=cl> (public_name simplederiver)
</span></span><span class=line><span class=cl> (name main)
</span></span><span class=line><span class=cl> (preprocess (pps ppx_deriving_accessors)))</span></span></code></pre></td></tr></table></div></div><ol start=4><li>构建，执行</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>dune build
</span></span><span class=line><span class=cl>dune <span class=nb>exec</span> bin/main.exe</span></span></code></pre></td></tr></table></div></div><h2 id=ppx的缺点 class=heading-element><span>PPX的缺点</span>
<a href=#ppx%e7%9a%84%e7%bc%ba%e7%82%b9 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>尽管PPX预处理机制具有类型安全、能够获取更丰富的源程序信息等优势，但与基于文本的预处理机制相比，它也存在一些缺点：</p><ul><li><strong>更高的复杂度</strong>：PPX扩展需要对OCaml的抽象语法树（AST）进行解析和转换，涉及更多的编译器内部机制。这使得PPX的学习曲线和调试难度相对较高。</li><li><strong>性能开销</strong>：尽管PPX是在编译时处理代码的，但由于其处理的是整个抽象语法树（AST），它可能比基于文本的预处理更耗费计算资源，尤其是在处理复杂的扩展时。</li><li><strong>灵活性不足</strong>：基于文本的预处理机制允许开发者自由定义宏，并进行简单的条件编译，非常适合在代码中进行灵活的字符串替换和条件操作。相比之下，PPX扩展机制更依赖于编译器的结构和规范，灵活性相对较低。虽然功能强大，但对于某些简单的预处理任务，可能会显得过于复杂。</li></ul><h2 id=总结 class=heading-element><span>总结</span>
<a href=#%e6%80%bb%e7%bb%93 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>OCaml的PPX预处理机制提供了一种强大且类型安全的方式来增强语言的功能。它允许开发者在编译前对代码进行复杂的转换和扩展，从而显著提高代码的表达能力和开发效率。通过PPX，开发者可以引入新的语法和功能，生成类型安全的代码，并充分利用OCaml编译器提供的类型信息。这种机制不仅为OCaml的生态系统带来了极大的灵活性，也为开发者提供了强大的工具来扩展语言的边界。</p><p>然而，PPX并非没有缺点。它需要开发者对OCaml的抽象语法树（AST）和编译器的工作原理有深入的了解，这无疑增加了学习和使用成本。此外，PPX的处理过程可能会引入额外的编译开销，尤其是在处理复杂的扩展时。尽管如此，PPX的这些缺点并没有掩盖它的巨大价值。在现代OCaml开发中，PPX已经成为不可或缺的一部分，它为语言的扩展和创新提供了无限可能。</p><p>在使用OCaml进行软件开发时，开发者需要合理利用PPX机制。一方面，应根据具体的业务场景，充分利用OCaml社区提供的丰富PPX扩展库。在必要时，开发者可以自行编写PPX扩展，以提升代码的表达能力和开发效率，从而更好地实现业务目标。另一方面，开发者应避免过度依赖PPX机制，以免引入不必要的复杂性，进而降低代码的可维护性和可读性。</p><p>总之，OCaml的PPX机制是一个功能强大的工具。作为开发者，我们应充分了解其优缺点，并根据实际需求合理使用。只有这样，才能在享受PPX带来的便利的同时，避免其可能带来的问题，从而更好地提升开发效率和代码质量。</p></div><hr class=awesome-hr><h2 id=see-also>相关内容</h2><ul><li><a href=/posts/2024/02/llvm-code-generator-1/ title=LLVM目标无关代码生成器（下）（译）>LLVM目标无关代码生成器（下）（译）</a></li><li><a href=/posts/2024/02/llvm-code-generator-0/ title=LLVM目标无关代码生成器（上）（译）>LLVM目标无关代码生成器（上）（译）</a></li><li><a href=/posts/2024/02/llvm-undef-poison/ title="笔记-LLVM IR中的undef和poison">笔记-LLVM IR中的undef和poison</a></li><li><a href=/posts/2022/02/importance-estimation/ title=如何确定事情的重要性>如何确定事情的重要性</a></li><li><a href=/posts/2021/12/mao-reading-of-moral-philosophy/ title=读《毛泽东关于“伦理学原理”的笔记》>读《毛泽东关于“伦理学原理”的笔记》</a></li></ul><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2025-02-18 18:15:13">更新于 2025-02-18&nbsp;</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/2025/02/ocaml-ppx-preprocessor/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://simplecoding.fun/posts/2025/02/ocaml-ppx-preprocessor/ data-title=OCaml的PPX预处理机制解析 data-hashtags=编译器,OCaml,编程语言><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://simplecoding.fun/posts/2025/02/ocaml-ppx-preprocessor/ data-hashtag=编译器><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://simplecoding.fun/posts/2025/02/ocaml-ppx-preprocessor/ data-title=OCaml的PPX预处理机制解析><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Blogger" data-sharer=blogger data-url=https://simplecoding.fun/posts/2025/02/ocaml-ppx-preprocessor/ data-title=OCaml的PPX预处理机制解析 data-description><i class="fa-brands fa-blogger fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/%E7%BC%96%E8%AF%91%E5%99%A8/ class=post-tag title="标签 - 编译器">编译器</a><a href=/tags/ocaml/ class=post-tag title="标签 - OCaml">OCaml</a><a href=/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/ class=post-tag title="标签 - 编程语言">编程语言</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/2025/02/reading-xiaogouqianqian/ class=post-nav-item rel=prev title=读《小狗钱钱》><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>读《小狗钱钱》</a></div></div><div id=comments><div id=twikoo></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://twikoo.js.org/ rel="external nofollow noopener noreferrer">Twikoo</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.144.0"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.17-8b402129"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2021 - 2025</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/wanghuibin0 target=_blank rel="external nofollow noopener noreferrer">lazypanda</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line visitor"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class="variant-numeric d-none">0%</span></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/wanghuibin0 title="Find Me on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/katex/katex.min.css></noscript><script src=/lib/twikoo/twikoo.all.min.js defer></script><script src=/lib/lightgallery/lightgallery.min.js defer></script><script src=/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/lib/autocomplete/autocomplete.min.js defer></script><script src=/lib/fuse/fuse.min.js defer></script><script src=/lib/sharer/sharer.min.js async defer></script><script src=/lib/katex/katex.min.js defer></script><script src=/lib/katex/auto-render.min.js defer></script><script src=/lib/katex/copy-tex.min.js defer></script><script src=/lib/katex/mhchem.min.js defer></script><script src=/lib/pangu/pangu.min.js defer></script><script src=https://vercount.one/js async defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:30},comment:{enable:!0,expired:!1,twikoo:{commentCount:!0,el:"#twikoo",envId:"https://simplecoding0.netlify.app/.netlify/functions/twikoo",lang:"zh-cn",lightgallery:!0}},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},pangu:{enable:!0,selector:"article"},search:{distance:100,findAllMatches:!1,highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:10,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:30,threshold:.3,useExtendedSearch:!1},version:"v0.3.17-8b402129"}</script><script src=/js/theme.min.js defer></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-CXXK5XBPFV",{anonymize_ip:!0})</script><script src="https://www.googletagmanager.com/gtag/js?id=G-CXXK5XBPFV" async></script></body></html>