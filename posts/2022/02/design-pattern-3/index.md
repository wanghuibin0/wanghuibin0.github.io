# 读书笔记-设计模式-结构型模式


## 适配器模式 {#适配器模式}


### 场景 {#场景}

想使用一个已经存在的类，而它的接口不符合需求


### 方案 {#方案}

-   基于多重继承的
    Adaptor类实现需要的接口，同时私有继承（实现继承）那个已经存在的类Adaptee。
    Adaptor类在实现接口的时候，将使用私有继承来的Adaptee来实现。
-   基于对象组合的
    Adaptor类实现需要的接口，其内部保存一个Adaptee的引用。
    Adaptor类在实现接口的时候，将委托Adaptee完成相应的功能。


### UML表示 {#uml表示}

-   基于多重继承的

    {{&lt; figure src=&#34;/ox-hugo/2022-02-06_18-50-27_screenshot.png&#34; &gt;}}
-   基于对象组合的

    {{&lt; figure src=&#34;/ox-hugo/2022-02-06_18-50-57_screenshot.png&#34; &gt;}}


### 两种方案的权衡 {#两种方案的权衡}

对象适配器比较灵活，允许适配Adaptee以及它的所有子类。而类适配器则不行。
对象适配器需要额外的指针，类适配器不需要。


## 桥接模式 {#桥接模式}


### 场景 {#场景}

要将抽象部分与它的实现部分分离，使它们都可以独立地变化


### 方案 {#方案}

将抽象和实现部分分别放在独立的类层次结构中，其中一个针对接口，另一个针对实现，针对接口的类层次结构需要保存一个关于实现的对象的引用。


### UML表示 {#uml表示}

{{&lt; figure src=&#34;/ox-hugo/2022-02-06_19-04-45_screenshot.png&#34; &gt;}}


### 其他 {#其他}

虽然UML类图与对象适配器很相似，但是两者的目的不同，对象适配器是为了实现接口的转换，而桥接模式是为了将接口和实现分离。


## 组合模式 {#组合模式}


### 场景 {#场景}

处理具有整体-部分层次结构特征的对象，一些复杂的组件是由简单的组件组合而成，这些复杂的组件又是更复杂组件的组成部分。
想对所有组件进行统一处理。


### 方案 {#方案}

关键是让所有组件继承自同一接口。复杂组件保存有简单组件的引用。
形成的动态结构是树状的。


### UML表示 {#uml表示}


#### 类图 {#类图}

{{&lt; figure src=&#34;/ox-hugo/2022-02-06_19-17-13_screenshot.png&#34; &gt;}}


#### 动态对象图 {#动态对象图}

{{&lt; figure src=&#34;/ox-hugo/2022-02-06_19-18-19_screenshot.png&#34; &gt;}}


## 装饰模式 {#装饰模式}


### 场景 {#场景}

希望给某个对象而不是整个类添加一些功能。用继承方式不够灵活。


### 方案 {#方案}

将组件嵌入另一个对象中（装饰对象保存有原组件的引用）。装饰对象接受到请求时，在将请求发给原组件前后，可以自由执行一些额外的动作。
由于原组件和所有的装饰类都继承自同一接口，所以可以递归地嵌套多个装饰对象，从而添加任意多的功能。
形成的动态结构有点类似于链表。


### UML表示 {#uml表示}

{{&lt; figure src=&#34;/ox-hugo/2022-02-06_19-32-11_screenshot.png&#34; &gt;}}


### 其他 {#其他}

与组合模式相比，可以将装饰视为一个退化的、仅有一个组件的组合。然而，装饰仅给对象添加一些额外的职责，而组合的目的在于对象的聚集。


## 外观模式 {#外观模式}


### 场景 {#场景}

为子系统的一组接口提供一个一致的界面


### 方案 {#方案}

提供一个高层接口，给客户一个一致的界面。而该接口的具体实现委托给子系统。


### UML表示 {#uml表示}

{{&lt; figure src=&#34;/ox-hugo/2022-02-06_19-43-44_screenshot.png&#34; &gt;}}


## 享元模式 {#享元模式}


### 场景 {#场景}

运行过程中创建了大量的对象，造成很大的存储开销。而且对象的大多数状态都可变为外部状态。


### 方案 {#方案}

享元模式通过共享技术实现相同或相似对象的重用。
在享元模式中可以共享的相同内容称为内部状态(Intrinsic State)，而那些需要外部环境来设置的不能共享的内容称为外部状态(Extrinsic State)，
由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。


### UML表示 {#uml表示}

{{&lt; figure src=&#34;/ox-hugo/2022-02-06_20-34-22_screenshot.png&#34; &gt;}}


## 代理模式 {#代理模式}


### 场景 {#场景}

一个客户不想或者不能直接引用一个对象


### 方案 {#方案}

通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对象作为真实对象的一个替身。


### UML表示 {#uml表示}

{{&lt; figure src=&#34;/ox-hugo/2022-02-06_20-43-37_screenshot.png&#34; &gt;}}


## 结构型模式的讨论 {#结构型模式的讨论}

1.  适配器模式和桥接模式
    适配器用于解决两个已有接口不匹配的问题。桥接模式是为了将抽象和实现两者独立演化。
2.  组合模式和装饰模式
    都基于递归组合来组织可变数目的对象，但目的不同。组合模式旨在使整体与部分统一处理，而装饰模式旨在给对象添加职责。


---

> 作者: [lazypanda](https://github.com/wanghuibin0)  
> URL: https://simplecoding.fun/posts/2022/02/design-pattern-3/  

