# 读书笔记-设计模式-引言


## 什么是设计模式 {#什么是设计模式}

特定场景下一类问题的通用解决方案。

需要说明的是，设计模式跟所使用的编程语言是很相关的。
比如，面向对象语言中的一些行为型模式在函数式语言中就不需要，而在面向对象语言直接支持「继承」、「封装」和「多态」，如果要在过程式语言中实现，也就需要特殊的「模式」了。
所以，所谓的模式跟编程语言自身的能力息息相关。


### 四个基本要素 {#四个基本要素}

1.  模式名
2.  问题
    解决的是什么样的问题
3.  解决方案
4.  效果


## 设计模式怎样解决设计问题 {#设计模式怎样解决设计问题}


### 寻找合适的对象 {#寻找合适的对象}

面向对象程序由对象组成，对象包括数据和对数据进行操作的方法。对象在受到客户的请求（消息）后，执行相应的操作。
客户请求是使对象执行操作的唯一方法，操作又是改变对象内部状态的唯一方法。

面向对象设计最困难的部分是将系统分解为对象集合。


#### 面向对象设计方法学 {#面向对象设计方法学}

-   写出问题描述，挑出名词和动词，进而创建相应的类和操作
-   关注于系统的协作和职责关系
-   对现实世界进行建模，再将分析时发现的对象转化到设计中

各方法的优劣并无定论


#### 设计模式如何起作用 {#设计模式如何起作用}

帮你确定并不明显的抽象和描述这些抽象的对象，使设计更灵活、复用性更好。


### 决定对象的粒度 {#决定对象的粒度}


### 指定对象接口 {#指定对象接口}


#### 操作的型构signature {#操作的型构signature}

对象声明的每一个操作指定操作名、作为参数的对象和返回值


#### 对象的接口interface {#对象的接口interface}

所定义的所有操作型构的集合。描述了该对象所能接受的全部请求的集合。


#### 类型type {#类型type}

是用来标识特定接口的一个名字。
一个对象可以有许多类型，且不同的对象可以共享同一个类型。
当一个类型的接口包含另一个类型的接口时，我们说它是另一个类型的子类型subtype，另一个类型则称为它的超类型supertype。
子类型继承了它的超类型的接口。


#### 接口的实现 {#接口的实现}

对象接口和其功能实现是分离的，两个具有相同接口的对象可以有完全不同的实现。


#### 动态绑定 {#动态绑定}

客户发送请求只需要看接口，但请求具体怎么被处理，要到运行时刻才受具体对象的具体实现约束。


#### 多态polymorphism {#多态polymorphism}

动态绑定允许你在运行时刻彼此替换有相同接口的对象，这种可替换性叫多态。


#### 设计模式如何起作用 {#设计模式如何起作用}

-   通过确定接口的主要组成部分以及经接口发送的数据类型，来帮我们定义接口。
-   指定接口之间的关系。


### 描述对象的实现 {#描述对象的实现}


#### 实例化 {#实例化}

由类创建一个对象，需要分配存储空间，并将操作与对象的内部数据联系起来。


#### 类继承 {#类继承}

子类包含父类定义的所有数据和操作。子类能够改进和重新定义它们父类的操作。


#### 抽象类 {#抽象类}

为子类定义公共接口。


#### 混入类mixin {#混入类mixin}

是给其他类提供可选择的接口或功能的类。与抽象类一样不能被实例化。mixin要求多继承。


#### 类class和类型type的区别 {#类class和类型type的区别}

一个对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。
对象的类型只与它的接口有关，接口即对象能响应的请求的集合。


#### 类继承和接口继承的区别 {#类继承和接口继承的区别}

类继承根据一个对象的实现定义了另一个对象的实现，是代码和表示的共享机制。主要为了复用。
接口继承描述了一个对象什么时候能被用来替代另一个对象。主要为了多态。
C++中，纯接口继承，接近于公有继承纯抽象类；纯实现继承或纯类继承接近于私有继承。


#### 针对接口编程 {#针对接口编程}

不将变量声明为某个特定的具体类的实例对象。不得已时，用创建型模式。


### 运用复用机制 {#运用复用机制}


#### 继承与组合 {#继承与组合}

实现功能复用的两种最常用技术是：类继承和对象组合，前者为白箱复用，后者为黑箱复用。
对象组合使设计更灵活，但是动态的、高度参数化的软件比静态软件更难以理解，而且还有运行低效的问题。
应该优先使用对象组合。
经验表明，设计者往往过度使用了继承这种复用技术。


#### 委托 {#委托}

委托是对象组合的特例。


#### 继承和参数化类型 {#继承和参数化类型}

C++ template


### 关联运行时刻和编译时刻的结构 {#关联运行时刻和编译时刻的结构}

如果将编译时刻的代码结构比作静态的动植物分类，那么运行时刻结构就如活生生的生态系统。


### 设计应支持变化 {#设计应支持变化}

先预测可能会发生哪些方面的变化，然后将这些变化抽象出来。


## 设计模式的分类 {#设计模式的分类}

-   创建型模式
    单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。
-   结构型模式
    适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
-   行为型模式
    模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。


---

> 作者: [lazypanda](https://github.com/wanghuibin0)  
> URL: https://simplecoding.fun/posts/2022/02/design-pattern-1/  

