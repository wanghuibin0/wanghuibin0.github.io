[{"categories":["个人成长"],"content":"读《改变心理学的40研究》，看到关于内控型和外控型人格的讨论，觉得蛮有意思，记录下来。 ","date":"2021-11-27","objectID":"/internal-and-external-control-personality/:0:0","tags":[],"title":"内控和外控型人格","uri":"/internal-and-external-control-personality/"},{"categories":["个人成长"],"content":"什么叫内控和外控 当人们把自己的行为后果归因为运气、命运或是他人力量的影响时，称为外控点的信念；与之相反，如果人们把行为后果归因于自己的行为和人格特征，则他们就具有一种内控点的信念。 ","date":"2021-11-27","objectID":"/internal-and-external-control-personality/:1:0","tags":[],"title":"内控和外控型人格","uri":"/internal-and-external-control-personality/"},{"categories":["个人成长"],"content":"形成原因 内、外控倾向形成的可能原因有三：文化差异、社会经济水平的差异以及父母教养方式的差异。 ","date":"2021-11-27","objectID":"/internal-and-external-control-personality/:2:0","tags":[],"title":"内控和外控型人格","uri":"/internal-and-external-control-personality/"},{"categories":["个人成长"],"content":"控制点的影响 控制点是一种在各种情景中一贯起作用的可界定的个体特征；而且，个体的内外控维度对行为的影响是使不同的人在面对同一情境时采取不同的行为。 ","date":"2021-11-27","objectID":"/internal-and-external-control-personality/:3:0","tags":[],"title":"内控和外控型人格","uri":"/internal-and-external-control-personality/"},{"categories":["个人成长"],"content":"与宗教信仰的关系 如果一个人具有外控倾向，但这种外部力量被认为是一种对至高无上的神灵（如上帝）的强烈信仰，那么也就不太可能陷入由外控倾向带来的一些典型问题（如无助感、抑郁、低水平的成就动机、缺少谋求改变现状的动机等）。这可以部分解释为什么一些人归于哲学，一些人归于宗教。 ","date":"2021-11-27","objectID":"/internal-and-external-control-personality/:4:0","tags":[],"title":"内控和外控型人格","uri":"/internal-and-external-control-personality/"},{"categories":["个人成长"],"content":"控制点的可变性 内外控是相对稳定的，但不是绝对。若有机会，个体能够通过学习来提高内控水平。 ","date":"2021-11-27","objectID":"/internal-and-external-control-personality/:5:0","tags":[],"title":"内控和外控型人格","uri":"/internal-and-external-control-personality/"},{"categories":["个人成长"],"content":"启示 尽管大多时候内控水平高的人可以更好地自我调节并适应生活，但是如果一个人打算改变不可能改变的情境，那么挫折沮丧和抑郁很可能随之而来。所以最理智的策略是认清哪些能改变的、哪些不能改变，合理的设置内外控界限。 如此看来，美国神学家尼布尔的祈祷词可谓经典： 上帝，请赐予我平静，去接受我无法改变的。 赐予我勇气， 去改变我能改变的。 赐予我智慧， 分辨这两者的区别。 ","date":"2021-11-27","objectID":"/internal-and-external-control-personality/:6:0","tags":[],"title":"内控和外控型人格","uri":"/internal-and-external-control-personality/"},{"categories":["编程语言"],"content":"TeX TeX 是 Donald Knuth 编写的一套排版系统，尤其擅长排版复杂的数学公式。TeX 语言定义了一套原语，用于对纯文本进行格式控制；并且在这些原语的基础上，定义了一系列宏，增加了TeX 语言的易用性。TeX 编译器用于编译 TeX文件，初期生成的文件为dvi格式。 ","date":"2021-11-24","objectID":"/tex-family/:1:0","tags":["Tex","LaTeX","writing"],"title":"TeX Family","uri":"/tex-family/"},{"categories":["编程语言"],"content":"pdfTeX, XeTeX \u0026 LuaTeX Donald Knuth 认为 TeX 已经够用，不希望 TeX 变得太复杂，决定不再往里面添加新功能，只接受bug fix。 随着新技术的发展，以及现代化排版的需要，一些人创建了几个TeX的变体：pdfTeX, XeTeX \u0026 LuaTeX。这些变体其实是在TeX的基础上，扩展了TeX的能力，增加了新的原语和特性。虽然这些变体都继承了TeX，但这些变体之间，相互是不兼容的。 ","date":"2021-11-24","objectID":"/tex-family/:2:0","tags":["Tex","LaTeX","writing"],"title":"TeX Family","uri":"/tex-family/"},{"categories":["编程语言"],"content":"pdfTeX 提供了直接输出pdf文件的能力 对TeX的排版做了一些细节上的调整 ","date":"2021-11-24","objectID":"/tex-family/:2:1","tags":["Tex","LaTeX","writing"],"title":"TeX Family","uri":"/tex-family/"},{"categories":["编程语言"],"content":"XeTeX 处理UTF-8编码，处理多国语言 可以方便地使用OpenType字体 ","date":"2021-11-24","objectID":"/tex-family/:2:2","tags":["Tex","LaTeX","writing"],"title":"TeX Family","uri":"/tex-family/"},{"categories":["编程语言"],"content":"LuaTeX 源于pdfTeX 支持Lua脚本语言 支持UTF-8编码 可以处理OpenType字体，但处理机制和XeTeX不同 支持MetaPost画图语言 支持通过C/C++写的.dll或.so插件来添加扩展功能 ","date":"2021-11-24","objectID":"/tex-family/:2:3","tags":["Tex","LaTeX","writing"],"title":"TeX Family","uri":"/tex-family/"},{"categories":["编程语言"],"content":"LaTeX 与刚讲的三个变体不同，LaTeX 并未扩展TeX的功能，而是给TeX写了一组macro，这些macro仍然是建立在TeX原语的基础之上。也就是说，LaTeX只是一批大量精心设计的macro的集合。 增加了很多对排版细节的控制，如页面布局，字体等，更加易用 可以方便地添加其他宏包，以便解决特定领域的排版问题 ","date":"2021-11-24","objectID":"/tex-family/:3:0","tags":["Tex","LaTeX","writing"],"title":"TeX Family","uri":"/tex-family/"},{"categories":["编程语言"],"content":"pdfLaTeX, XeLaTeX \u0026 LuaLaTeX pdfLaTeX = LaTeX macro package + pdfTeX engine XeLaTeX = LaTeX macro package + XeTeX engine LuaLaTeX = LaTeX macro package + LuaTeX engine ","date":"2021-11-24","objectID":"/tex-family/:4:0","tags":["Tex","LaTeX","writing"],"title":"TeX Family","uri":"/tex-family/"},{"categories":["个人成长"],"content":"My First Post This is my first post. Just for testing… ","date":"2021-11-23","objectID":"/my-first-post/:0:0","tags":null,"title":"My First Post","uri":"/my-first-post/"},{"categories":["个人成长"],"content":"Subtitle Qoute something: 男儿何不带吴钩，收取关山五十州。 ","date":"2021-11-23","objectID":"/my-first-post/:1:0","tags":null,"title":"My First Post","uri":"/my-first-post/"},{"categories":["编程语言"],"content":"要让计算机帮你做事情，你一定要把你的想法告诉计算机。怎么告诉呢？靠编程语言。这就好像人和人交流要靠语言（手势表情也算特殊的语言），人和计算机交流也要靠语言，靠编程语言。但是说到底，语言只是一个载体，它承载的背后的人的想法，才是最关键的。人的编程活动，就是把人的想法用编程语言编码，交给机器后它再解码，然后按照我们的想法去做事情。看起来就好像机器“理解”了人的想法，这也是自从有了计算机，大家觉得人工智能不再那么遥远的原因。可是，大家都在忙着神经网络，深度学习，似乎忽略了一件事情：那就是人和机器的牵线人——编程语言。编程语言有能力表达人的想法吗？什么样的编程语言才是机器能够处理的？或者说，是否存在一种编程语言，能够充分表达人的想法，又能被机器理解呢？这就涉及到编程语言的语义。 本文只是介绍编程语言语义学的一些基本概念，肯定是无法回答这么宏大的问题的。但是，这些概念却是基础，是进一步思考的起点。 ","date":"2021-04-21","objectID":"/2021-04-21-program-semantics/:0:0","tags":["形式语义"],"title":"编程语言的形式语义","uri":"/2021-04-21-program-semantics/"},{"categories":["编程语言"],"content":"编程语言 语言有两大要素——语法和语义，语法是看得见的表面的形式，语义是真正想表达的背后的含义。各种五发八门的不同的编程语言，其表面形式可以天差地别，但其背后的语义却是相通的。只有使计算机「理解」了人类想表达的东西，才有可能准确给出人类想要的结果。当然也需要计算机拥有对应的计算能力，这正是计算理论所研究的内容，各种计算模型，如有限状态自动机，下推自动机，图灵机，确定性的，不确定性的等等，计算能力的确有差别。不过这一切的前提是你得想办法把自己的想法「告诉」计算机，这就绕不开计算机程序的语义。 ","date":"2021-04-21","objectID":"/2021-04-21-program-semantics/:1:0","tags":["形式语义"],"title":"编程语言的形式语义","uri":"/2021-04-21-program-semantics/"},{"categories":["编程语言"],"content":"形式语义 形式语义试图精确地、无歧义地描述程序的含义，并利用这些含义研究程序的性质。现实中，程序的语义通常有两种方式描述：一种是靠实现规范，如Ruby解释器有一个参考实现；另一种是写一份平实的官方规范，如C++/Java/ECMAScript。 而从更加形式化也更加数学化的角度看，描述程序可以由三种语义：操作语义、指称语义和公理语义。 ","date":"2021-04-21","objectID":"/2021-04-21-program-semantics/:2:0","tags":["形式语义"],"title":"编程语言的形式语义","uri":"/2021-04-21-program-semantics/"},{"categories":["编程语言"],"content":"操作语义 操作语义为程序在某种机器的执行定义一些规则，来捕捉编程语言的含义。这个机器通常是一种抽象的机器：为了解释这种语言所写的程序如何执行，而设计出来的一种想象的、理想化的计算机。操作语义又分为小步操作语义和大步操作语义。 小步操作语义 假想一台机器，用这台机器直接按照这种语言的语法进行操作一小步ー小步地对其进行反复规约，从而对一个程序求值。这种语义相当于为程序实现了一种迭代式的解释器。 大步操作语义 大步语义的思想是，定义如何从一个表达式或者语句直接得到它的结果。这必然需要把程序的执行当成一个递归的而不是迭代的过程。也就是说，为了对一个更大的表达式求值，我们要对所有比它小的子表达式求值，然后把结果结合起来得到最终答案。这种语义相当于为程序实现了一种递归式的解释器。 ","date":"2021-04-21","objectID":"/2021-04-21-program-semantics/:2:1","tags":["形式语义"],"title":"编程语言的形式语义","uri":"/2021-04-21-program-semantics/"},{"categories":["编程语言"],"content":"指称语义 用一种更低级更形式化的语言，或者至少比被描述的语言更好理解的语言，来描述新的语言。它更抽象，与操作语义更像解释器相比，它更像编译器。 ","date":"2021-04-21","objectID":"/2021-04-21-program-semantics/:2:2","tags":["形式语义"],"title":"编程语言的形式语义","uri":"/2021-04-21-program-semantics/"},{"categories":["编程语言"],"content":"公理语义 通过在语句执行前后，分别给出抽象机器状态的断言，来描述一个语句的含义：如果前置条件在语句执行前初始化为true，那么执行后的后置条件也保证为true。公理语义主要用于验证程序的正确性。 ","date":"2021-04-21","objectID":"/2021-04-21-program-semantics/:2:3","tags":["形式语义"],"title":"编程语言的形式语义","uri":"/2021-04-21-program-semantics/"},{"categories":["神奇的工具"],"content":"缘起 在 vps 上部署了几个服务：nextcloud、ttrss、siyuan。这些服务监听着不同的端口，从浏览器访问时，必须输入特定的端口才能连上对应的服务。于是我突发奇想，何不效仿 dns 做法，用直观的名字去映射难记的数字呢？说干就干，决定用反向代理软件 Nginx，实现我这个想法。 ","date":"2021-04-05","objectID":"/2021-04-05-use-nginx-to-dispatch-requests-to-service/:0:1","tags":["计算机网络","服务器"],"title":"利用Nginx实现服务请求按名称分发","uri":"/2021-04-05-use-nginx-to-dispatch-requests-to-service/"},{"categories":["神奇的工具"],"content":"实现方法 在 Nginx 中配置一个虚拟服务器端口，做为分发前的总入口，然后利用 location 字段，针对不同路径做分发，重定向至对应服务的端口，即可。具体如下： server { listen 127.0.0.1:8080; location ~ /ttrss { #access_log /home/wanghb/nginx-log/ttrss-access.log; #error_log /home/wanghb/nginx-log/ttrss-error.log debug; return 301 http://$server_name:portA; } location ~ /nextcloud { return 301 http://$server_name:portB/apps/dashboard/; } location ~ /siyuan { return 301 http://$server_name:portC/stage/build/desktop/; } location / { proxy_pass https://wanghuibin0.github.io; } } ","date":"2021-04-05","objectID":"/2021-04-05-use-nginx-to-dispatch-requests-to-service/:0:2","tags":["计算机网络","服务器"],"title":"利用Nginx实现服务请求按名称分发","uri":"/2021-04-05-use-nginx-to-dispatch-requests-to-service/"},{"categories":["神奇的工具"],"content":"效果 效果就是，在浏览器输入 https://server-name:8080/ttrss，能自动重定向到 ttrss 服务的端口去，其他两个服务亦然。最后一个 location / {} 块的含义是，如果与前面都不匹配，就默认反向代理自己的博客网站。 ps: 最开始，想用 proxy_pass 反向代理的方式实现路径分流，但是对 Nginx 配置不熟，捣鼓半天也没成功，后来改为 return 301 重定向的方法，很容易达到了自己想要的效果。 pps: 中间曾觉得 Nginx 配置太复杂，一度想换 caddy 做。但是在了解 caddy 的过程中，发现 caddy 也不是完美的，简单是简单一些，但灵活性不如 Nginx。后来遂换回 Nginx。不过现在想想，如果只是简单的重定向，caddy 应该也是能够胜任的。 ","date":"2021-04-05","objectID":"/2021-04-05-use-nginx-to-dispatch-requests-to-service/:0:3","tags":["计算机网络","服务器"],"title":"利用Nginx实现服务请求按名称分发","uri":"/2021-04-05-use-nginx-to-dispatch-requests-to-service/"},{"categories":["神奇的工具"],"content":"今天在浏览《科技爱好者周刊》时，学会了一个神奇的技能：VPN over SSH，直接利用ssh搭建一个简易的VPN。虽然现在有了V2ray/Xray/Trojan/SSR等各种代理工具，但是这些都需要额外的步骤安装部署，如果只是临时使用的话，远远没有VPN over SSH简单方便，因为SSH在PC和服务器上基本都是标配了。 话不多说，直接开始。 ","date":"2021-04-02","objectID":"/2021-04-02-vpn-over-ssh/:0:0","tags":["计算机网络"],"title":"VPN over SSH","uri":"/2021-04-02-vpn-over-ssh/"},{"categories":["神奇的工具"],"content":"创建SOCKS代理 $ ssh -NTCD 12345 username@SSH_remote_host_IP -N Do not execute a remote command -T Disable pseudo-terminal allocation -C Requests compression of all data -D \u003cport\u003e Specifies a local “dynamic” application-level port forwarding. This works by allocating a socket to listen to the port on the local side, optionally Whenever a connection is made to this port, the connection is forwarded over the secure channel, and the application protocol is then used to determine where to connect to from the remote machine. Currently the SOCKS4 and SOCKS5 protocols are supported, and ssh will act as a SOCKS server. 上述命令直接在本机创建了一个SOCKS服务器，监听端口为12345。 ","date":"2021-04-02","objectID":"/2021-04-02-vpn-over-ssh/:0:1","tags":["计算机网络"],"title":"VPN over SSH","uri":"/2021-04-02-vpn-over-ssh/"},{"categories":["神奇的工具"],"content":"浏览器使用SOCKS代理 可以在internet选项-\u003e连接里面修改，也可以利用Proxy SwitchyOmega等插件。 ","date":"2021-04-02","objectID":"/2021-04-02-vpn-over-ssh/:0:2","tags":["计算机网络"],"title":"VPN over SSH","uri":"/2021-04-02-vpn-over-ssh/"},{"categories":["神奇的工具"],"content":"其他软件使用SOCKS代理 SOCKS是比较低层的协议，如果按照OSI模型来讲的话，SOCKS应该属于会话层，所以更高层的协议如FTP/HTTP/SSH等都可以利用SOCK5代理通信。 SSH 特别简单，只需要一条命令： ssh -o ProxyCommand='nc -x localhost:12345 %h %p' username@**Far_Away_Host** 其他 可针对具体软件具体设置。 ","date":"2021-04-02","objectID":"/2021-04-02-vpn-over-ssh/:0:3","tags":["计算机网络"],"title":"VPN over SSH","uri":"/2021-04-02-vpn-over-ssh/"},{"categories":["神奇的工具"],"content":"sshuttle sshuttle也是一个基于ssh实现vpn的工具，使用也很简单：$ sshuttle -r username**@SSH_remote_host_IP** 0.0.0.0/0，就可以将本机上所有流量转发到远程vps上去，实现代理通信，就不用再手动进行各软件的代理设置了。不过个人认为，对于简单的需求，临时vpn代理，单纯的ssh就可以了，要是有更复杂的需求，还是用xray这种专门的科学上网工具好了，sshuttle反而没太大必要。 ","date":"2021-04-02","objectID":"/2021-04-02-vpn-over-ssh/:0:4","tags":["计算机网络"],"title":"VPN over SSH","uri":"/2021-04-02-vpn-over-ssh/"},{"categories":["神奇的工具"],"content":"参考 VPN over SSH? The SOCKS Proxy ","date":"2021-04-02","objectID":"/2021-04-02-vpn-over-ssh/:0:5","tags":["计算机网络"],"title":"VPN over SSH","uri":"/2021-04-02-vpn-over-ssh/"},{"categories":["神奇的工具"],"content":"缘起 在学习南大的课程程序设计语言的形式语义时，要下载课件，一个一个去下太麻烦了，这么机械性的工作，当然交给脚本来做最合适啦，而且这种事情以后肯定还要用到，于是写了一个python脚本，可以从指定的页面，把所有的ppt和pdf文件下载下来。 ","date":"2021-03-19","objectID":"/2021-03-19-download-ppt-and-pdf-files-md/:1:0","tags":["爬虫","python"],"title":"课件下载利器","uri":"/2021-03-19-download-ppt-and-pdf-files-md/"},{"categories":["神奇的工具"],"content":"课件下载脚本 ","date":"2021-03-19","objectID":"/2021-03-19-download-ppt-and-pdf-files-md/:2:0","tags":["爬虫","python"],"title":"课件下载利器","uri":"/2021-03-19-download-ppt-and-pdf-files-md/"},{"categories":["神奇的工具"],"content":"用法示例 命令行执行如下命令 python3 slides-downloader.py https://cs.nju.edu.cn/hongjin/teaching/semantics/index.htm slides 正常会出现如下运行界面：如此，便可以愉快的下载课件啦，就可以把更多时间用来学(mo)习(yu)啦~~~ ","date":"2021-03-19","objectID":"/2021-03-19-download-ppt-and-pdf-files-md/:3:0","tags":["爬虫","python"],"title":"课件下载利器","uri":"/2021-03-19-download-ppt-and-pdf-files-md/"},{"categories":["神奇的工具"],"content":"从zotero到思源 ","date":"2021-03-15","objectID":"/2021-03-15-relate-zotero-with-siyuan/:1:0","tags":["zotero"],"title":"zotero与SiYuan联动","uri":"/2021-03-15-relate-zotero-with-siyuan/"},{"categories":["神奇的工具"],"content":"原理 修改zotero的engines.json文件，将思源作为zotero的搜索引擎之一，从zotero跳转到思源的对应页面。 ","date":"2021-03-15","objectID":"/2021-03-15-relate-zotero-with-siyuan/:1:1","tags":["zotero"],"title":"zotero与SiYuan联动","uri":"/2021-03-15-relate-zotero-with-siyuan/"},{"categories":["神奇的工具"],"content":"engines.json 关键就在于搜索引擎跳转使用的url模板，跳转时会根据文献条目的信息，填充到url模板里，然后再跳转到产生的url地址去。因此需要将定位思源的url进行拆分，将不变部分抽取出来作为模板，变化的部分作为变量填到文献条目的信息里，实际上，我们使用的是archive字段。 engines.json添加如下entry: { \"_name\": \"SiYuan\", \"_alias\": \"SiYuan\", \"_description\": \"Zotero和思源联动，页面ID存在archive字段\", \"_icon\": \"https://cdn.jsdelivr.net/gh/wanghuibin0/picbed@main/img/20210312191013.png\", \"_hidden\": false, \"_urlTemplate\": \"http://127.0.0.1:6806/blocks/{z:archive}\", \"_urlParams\": [], \"_urlNamespaces\": { \"z\": \"http://www.zotero.org/namespaces/openSearch#\", \"\": \"http://a9.com/-/spec/opensearch/1.1/\" }, \"_iconSourceURI\": \"https://cdn.jsdelivr.net/gh/wanghuibin0/picbed@main/img/20210312191013.png\" }, 点击下载完整的engines.json，可以直接拷贝到zotero的数据文件夹下的locate目录下。 ","date":"2021-03-15","objectID":"/2021-03-15-relate-zotero-with-siyuan/:1:2","tags":["zotero"],"title":"zotero与SiYuan联动","uri":"/2021-03-15-relate-zotero-with-siyuan/"},{"categories":["神奇的工具"],"content":"将思源笔记页面关联到zotero中 使用中，需要先将思源中对应页面id（在对应笔记处点「复制URL」，截取斜杠号分割之后的最后一段，即为id），填到文献条目archive字段去。这样，产生的url刚好能跳转到对应的笔记去。 ","date":"2021-03-15","objectID":"/2021-03-15-relate-zotero-with-siyuan/:1:3","tags":["zotero"],"title":"zotero与SiYuan联动","uri":"/2021-03-15-relate-zotero-with-siyuan/"},{"categories":["神奇的工具"],"content":"从思源到zotero 由于zotero支持形式如zotero://XXX的链接，所以可以直接在思源笔记需要的地方填入这种链接。利用链接，可以跳转到对应的zotero item，也可以直接打开附件pdf，甚至可以定位到pdf的特定页面。 查看文献条目：zotero://select/library/items/CSUJ2GFP 查看附件pdf特定页：zotero://open-pdf/library/items/ITBGH4GB?page=2 ","date":"2021-03-15","objectID":"/2021-03-15-relate-zotero-with-siyuan/:2:0","tags":["zotero"],"title":"zotero与SiYuan联动","uri":"/2021-03-15-relate-zotero-with-siyuan/"},{"categories":["神奇的工具"],"content":"参考 zotero 和思源笔记探索 - 链滴 (ld246.com) 重磅｜Zotero + wolai 双向联动教程 - 知乎 (zhihu.com) ","date":"2021-03-15","objectID":"/2021-03-15-relate-zotero-with-siyuan/:3:0","tags":["zotero"],"title":"zotero与SiYuan联动","uri":"/2021-03-15-relate-zotero-with-siyuan/"},{"categories":["神奇的工具"],"content":"用 python 模拟登录链滴 ","date":"2021-03-14","objectID":"/2021-03-14-a-problem-in-simulation-of-liandi-login/:0:0","tags":["爬虫","python"],"title":"模拟登录链滴网站","uri":"/2021-03-14-a-problem-in-simulation-of-liandi-login/"},{"categories":["神奇的工具"],"content":"分析登录流程 通过浏览器抓包发现，登录过程就是向服务器发送一个 POST 请求，用户名密码伴随此请求传递给服务器。 很容易看出，密码是明文经过加密后再传出去的，但是加密后的密码是不会变的，跟明文密码是对应的。模拟登录时，只需加密后的字符串复制过来给 POST 请求即可。 ","date":"2021-03-14","objectID":"/2021-03-14-a-problem-in-simulation-of-liandi-login/:0:1","tags":["爬虫","python"],"title":"模拟登录链滴网站","uri":"/2021-03-14-a-problem-in-simulation-of-liandi-login/"},{"categories":["神奇的工具"],"content":"编写脚本 于是开始撸 python 脚本（下面是脚本的核心部分）： login_url = 'https://ld246.com/login' login_headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36 Edg/89.0.774.50', } data = {\"nameOrEmail\":\"XXXX\",\"userPassword\":\"XXXX\",\"captcha\":\"\"} try: r = requests.post(login_url, headers=login_headers, json=data) r.raise_for_status() #如果状态码不是200,抛出HTTPError异常 r.encoding = r.apparent_encoding return r.text except: return \"产生异常\" ","date":"2021-03-14","objectID":"/2021-03-14-a-problem-in-simulation-of-liandi-login/:0:2","tags":["爬虫","python"],"title":"模拟登录链滴网站","uri":"/2021-03-14-a-problem-in-simulation-of-liandi-login/"},{"categories":["神奇的工具"],"content":"遇到的小问题 刚开始 post 请求写成了 r = requests.post(login_url, headers=login_headers, data=data)，然后就死活登录不成功，服务器总是返回“密码错误”，后来把 data=data 改为 json=data 才解决问题。 Python requests.post 方法中 data 与 json 参数区别 - 随风飘-挨刀刀 - 博客园 (cnblogs.com) 其实在抓包时，是可以看出 json 和 data 在提交表单那里是不一样的。 ps: 本来我以为是网站有反爬措施，还研究了它的 cookie 生成机制，结果发现其实并没有什么反爬措施。 ","date":"2021-03-14","objectID":"/2021-03-14-a-problem-in-simulation-of-liandi-login/:0:3","tags":["爬虫","python"],"title":"模拟登录链滴网站","uri":"/2021-03-14-a-problem-in-simulation-of-liandi-login/"},{"categories":["编程语言"],"content":"今天有一个猜想：c++函数局部构造的class/struct，如果要返回给父函数，是通过移动语义实现的。 但我并不十分确定，于是做了个实验验证之。 #include \u003ciostream\u003eusing namespace std; class A { public: A() : a{0} { cout \u003c\u003c \"constructing A\\n\"; } A(const A\u0026 other) : a{other.a} { cout \u003c\u003c \"copy constructing A\\n\"; } A(A\u0026\u0026 other) : a{other.a} { cout \u003c\u003c \"move constructing A\\n\"; } void goo() { a = a * 2; cout \u003c\u003c \"calling goo\\n\"; } private: int a; }; A foo(A x) { x.goo(); return x; } int main() { A x; A y = foo(x); return 0; } 不加任何优化选项，编译运行。 输出结果如下： constructing A copy constructing A calling goo move constructing A 结果验证了我的猜想，即：返回局部构造的class/struct时，是移动语义，调用的是移动构造函数（前提是存在移动构造函数，如果只实现了拷贝构造函数，那么移动构造函数就不存在，这时只能调用拷贝构造函数）。 目的是将子函数构造的对象转交给父函数，从高层语义上讲，调用移动或拷贝构造函数应该都是可以的。但是，由于局部变量在函数结束时需要销毁，如果先拷贝再把自身销毁，效率有亏。而直接将自己掌握的资源移动给父函数，效率更高。所以，至少在g++编译器实现上，采用的是移动语义。至于c++标准对此有无规定，尚不得而知。 ","date":"2021-01-12","objectID":"/2021-01-12-record-a-cpp-experiment/:0:0","tags":["c++"],"title":"记录一次C++实验","uri":"/2021-01-12-record-a-cpp-experiment/"},{"categories":["编程语言"],"content":"C++语言设计的两个基本原则 不给比C++更底层的语言留任何余地 零开销抽象 ","date":"2021-01-12","objectID":"/2021-01-12-c-programming-language/:0:0","tags":["c++"],"title":"C++-programming-language","uri":"/2021-01-12-c-programming-language/"},{"categories":null,"content":"关于本站 写字，思考，分享 ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"}]